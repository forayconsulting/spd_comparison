<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SPD MATRIX</title>

  <!-- External Dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script>

  <!-- Excel Generation Library -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <!-- Modern Tech-Forward Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Space+Grotesk:wght@500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    :root {
      /* SPD MATRIX - Professional Navy Blue Theme */

      /* Primary Brand Colors */
      --brand-navy: #1e3a5f;
      --brand-navy-light: #2d4a6f;
      --brand-navy-dark: #152a47;

      /* Background Colors */
      --bg-primary: #ffffff;
      --bg-secondary: #f7f9fc;
      --bg-tertiary: #eef2f7;

      /* Surface Colors (for glass effects) */
      --surface-glass: rgba(255, 255, 255, 0.88);
      --surface-elevated: rgba(30, 58, 95, 0.04);

      /* Gradients */
      --gradient-primary: linear-gradient(135deg, #1e3a5f 0%, #2d4a6f 100%);
      --gradient-accent: linear-gradient(135deg, #2d4a6f 0%, #3d5a7f 100%);
      --gradient-success: linear-gradient(135deg, #0d6e6e 0%, #1a8a8a 100%);
      --gradient-border: linear-gradient(135deg, rgba(30, 58, 95, 0.1), rgba(30, 58, 95, 0.15));

      /* Text Colors */
      --text-primary: #1a2b3c;
      --text-secondary: #5a6b7c;
      --text-muted: #8a9bac;

      /* Accent Colors */
      --accent-primary: #1e3a5f;
      --accent-hover: #2d4a6f;
      --accent-success: #0d6e6e;
      --accent-dark: #152a47;
      --accent-gray: #5a6b7c;
      --accent-light: #8a9bac;

      /* Borders */
      --border-subtle: rgba(30, 58, 95, 0.08);
      --border-medium: rgba(30, 58, 95, 0.15);

      /* Shadows (navy-tinted) */
      --shadow-sm: 0 2px 8px rgba(30, 58, 95, 0.08);
      --shadow-md: 0 4px 16px rgba(30, 58, 95, 0.12);
      --shadow-lg: 0 8px 32px rgba(30, 58, 95, 0.16);
      --shadow-glow: 0 0 40px rgba(30, 58, 95, 0.15);

      /* Error */
      --error: #d32f2f;
      --error-bg: rgba(211, 47, 47, 0.08);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      height: 100vh;
      overflow: hidden;
      position: relative;
    }

    /* Subtle static background pattern */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 0% 0%, rgba(30, 58, 95, 0.03) 0%, transparent 50%),
                  radial-gradient(circle at 100% 100%, rgba(30, 58, 95, 0.02) 0%, transparent 50%);
      pointer-events: none;
      z-index: 0;
    }

    .chat-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      max-width: 100%;
      margin: 0 auto;
      padding: 0;
      position: relative;
      z-index: 1;
    }

    /* SPD MATRIX Header with Navy Gradient */
    .chat-header {
      padding: 16px 32px;
      border-bottom: none;
      background: var(--gradient-primary);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: relative;
      box-shadow: var(--shadow-md);
    }

    .chat-header::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: var(--gradient-border);
    }

    .chat-header h1 {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 28px;
      font-weight: 700;
      color: white;
      letter-spacing: -0.02em;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo-icon {
      color: white;
      flex-shrink: 0;
    }

    .settings-button {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 10px;
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .settings-button:hover {
      background: rgba(255, 255, 255, 0.25);
    }

    .header-buttons {
      display: flex;
      gap: 8px;
    }

    .history-button {
      position: relative;
    }

    .history-badge {
      position: absolute;
      top: -4px;
      right: -4px;
      min-width: 18px;
      height: 18px;
      background: var(--accent);
      color: white;
      font-size: 11px;
      font-weight: 600;
      border-radius: 9px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 4px;
    }

    /* History Panel */
    .history-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 320px;
      height: 100vh;
      background: rgba(30, 30, 35, 0.95);
      backdrop-filter: blur(20px);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 1000;
      transform: translateX(100%);
      transition: transform 0.3s ease;
      display: flex;
      flex-direction: column;
    }

    .history-panel.open {
      transform: translateX(0);
    }

    .history-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .history-panel-header h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      color: white;
    }

    .history-close-button {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      transition: all 0.2s ease;
    }

    .history-close-button:hover {
      background: rgba(255, 255, 255, 0.1);
      color: white;
    }

    .new-analysis-button {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: calc(100% - 32px);
      margin: 16px;
      padding: 12px 16px;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2));
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 10px;
      color: white;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .new-analysis-button:hover {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(139, 92, 246, 0.3));
      border-color: rgba(99, 102, 241, 0.5);
      transform: translateY(-1px);
    }

    .new-analysis-button svg {
      flex-shrink: 0;
    }

    .history-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .history-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--text-secondary);
      text-align: center;
      gap: 12px;
    }

    .history-empty p {
      margin: 0;
    }

    .history-empty-hint {
      font-size: 13px;
      opacity: 0.7;
    }

    .history-date-group {
      margin-bottom: 20px;
    }

    .history-date-label {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
      padding-left: 4px;
    }

    .history-card {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 12px 14px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .history-card:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .history-card-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }

    .history-card-title {
      font-size: 14px;
      font-weight: 500;
      color: white;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
      cursor: pointer;
    }

    .history-card-title:hover {
      text-decoration: underline;
    }

    .history-edit-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      opacity: 0;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .history-card:hover .history-edit-btn {
      opacity: 1;
    }

    .history-edit-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      color: white;
    }

    .history-card-meta {
      font-size: 12px;
      color: var(--text-secondary);
      display: flex;
      gap: 6px;
    }

    .history-section-label {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      padding: 8px 0;
      margin-bottom: 8px;
    }

    .history-card-owner {
      font-size: 11px;
      color: var(--accent-primary);
      margin-bottom: 4px;
      cursor: pointer;
    }

    .history-card.shared {
      border-left: 3px solid var(--accent-primary);
    }

    /* Re-upload notice */
    .reupload-notice {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      background: rgba(255, 193, 7, 0.1);
      border: 1px solid rgba(255, 193, 7, 0.3);
      border-radius: 10px;
      margin-bottom: 16px;
      color: #ffc107;
      font-size: 13px;
    }

    .reupload-notice svg {
      flex-shrink: 0;
    }

    .model-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: rgba(255, 255, 255, 0.15);
      padding: 8px 16px;
      border-radius: 12px;
      font-size: 13px;
      color: white;
      font-weight: 500;
      border: 1px solid rgba(255, 255, 255, 0.25);
      box-shadow: var(--shadow-sm);
      position: relative;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .model-badge::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.1);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .model-badge:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
      background: rgba(255, 255, 255, 0.2);
    }

    .model-badge:hover::before {
      opacity: 1;
    }

    /* API Key Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 20px;
    }

    .modal {
      background: var(--bg-primary);
      border: 1px solid var(--border-medium);
      border-radius: 16px;
      padding: 32px;
      max-width: 500px;
      width: 100%;
      box-shadow: var(--shadow-xl);
    }

    .modal h2 {
      font-family: 'Inter', sans-serif;
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
      margin: 0 0 8px 0;
    }

    .modal p {
      color: var(--text-secondary);
      margin: 0 0 24px 0;
      line-height: 1.5;
    }

    .modal label {
      display: block;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 8px;
      font-size: 14px;
    }

    .modal input[type="text"],
    .modal input[type="password"] {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid var(--border-medium);
      border-radius: 8px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      margin-bottom: 8px;
      box-sizing: border-box;
    }

    .modal input:focus {
      outline: none;
      border-color: var(--text-primary);
    }

    .modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 24px;
    }

    .modal-button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .modal-button.primary {
      background: var(--gradient-primary);
      color: white;
    }

    .modal-button.primary:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .modal-button.secondary {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border-medium);
    }

    .modal-button.secondary:hover {
      background: var(--surface-glass);
    }

    /* Share Modal */
    .share-modal {
      background: var(--bg-primary);
      border: 1px solid var(--border-medium);
      border-radius: 16px;
      max-width: 480px;
      width: 100%;
      box-shadow: var(--shadow-xl);
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .share-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 24px;
      border-bottom: 1px solid var(--border-subtle);
    }

    .share-modal-header h2 {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0;
    }

    .modal-close-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 4px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-close-btn:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    .share-modal-content {
      padding: 24px;
      overflow-y: auto;
    }

    .share-section {
      margin-bottom: 24px;
    }

    .share-section:last-child {
      margin-bottom: 0;
    }

    .share-section h3 {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0 0 12px 0;
    }

    .share-hint {
      font-size: 12px;
      color: var(--text-secondary);
      margin: 0 0 12px 0;
    }

    .share-email-input {
      display: flex;
      gap: 8px;
    }

    .share-email-input input {
      flex: 1;
      padding: 10px 14px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 14px;
    }

    .share-email-input input:focus {
      outline: none;
      border-color: var(--accent-primary);
    }

    .share-email-input button,
    .create-link-btn {
      padding: 10px 16px;
      background: var(--accent-primary);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap;
    }

    .share-email-input button:hover,
    .create-link-btn:hover {
      opacity: 0.9;
    }

    .shares-list {
      margin-top: 12px;
    }

    .share-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 12px;
      background: var(--bg-secondary);
      border-radius: 8px;
      margin-bottom: 8px;
    }

    .share-item-info {
      flex: 1;
      min-width: 0;
    }

    .share-item-email,
    .share-item-url {
      font-size: 13px;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .share-item-meta {
      font-size: 11px;
      color: var(--text-secondary);
      margin-top: 2px;
    }

    .share-item-actions {
      display: flex;
      gap: 4px;
      margin-left: 8px;
    }

    .share-item-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 6px;
      border-radius: 6px;
    }

    .share-item-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .share-item-btn.delete:hover {
      color: #ef4444;
    }

    .api-key-hint {
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 16px;
    }

    .api-key-hint a {
      color: var(--text-primary);
      text-decoration: underline;
    }

    .thinking-indicator-badge {
      background: var(--border-medium);
      color: var(--text-secondary);
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      position: relative;
      z-index: 1;
    }

    /* Messages Area */
    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 32px;
      scroll-behavior: smooth;
      position: relative;
    }

    /* Custom Scrollbar */
    .messages-container::-webkit-scrollbar {
      width: 8px;
    }

    .messages-container::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }

    .messages-container::-webkit-scrollbar-thumb {
      background: var(--surface-elevated);
      border-radius: 4px;
    }

    .messages-container::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .message {
      margin-bottom: 32px;
      animation: slideInUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
    }

    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(20px) scale(0.98);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .message-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
      font-size: 12px;
      font-weight: 700;
      color: var(--text-secondary);
      font-family: 'JetBrains Mono', monospace;
      text-transform: uppercase;
      letter-spacing: 1.5px;
    }

    .message-role {
      position: relative;
      padding-left: 16px;
    }

    .message-role::before {
      content: '‚óè';
      position: absolute;
      left: 0;
      color: var(--accent-primary);
      animation: pulse 2s ease infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .message.user .message-role::before {
      color: var(--text-secondary);
    }

    /* Glass Morphism Message Cards */
    .message-content {
      background: var(--surface-glass);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      padding: 24px;
      border-radius: 16px;
      border: 1px solid var(--border-medium);
      box-shadow: var(--shadow-md);
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .message-content::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: var(--gradient-primary);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .message-content:hover {
      border-color: rgba(0, 0, 0, 0.2);
      box-shadow: var(--shadow-lg);
    }

    .message-content:hover::before {
      opacity: 1;
    }

    .message.user .message-content {
      background: rgba(0, 0, 0, 0.02);
      border-color: rgba(0, 0, 0, 0.15);
    }

    .message.user .message-content::before {
      background: var(--gradient-success);
    }

    /* Thinking Block with Tech Aesthetic */
    .thinking-block {
      background: rgba(0, 0, 0, 0.02);
      border-left: 3px solid var(--text-primary);
      padding: 16px 20px;
      margin: 16px 0;
      border-radius: 12px;
      font-family: 'JetBrains Mono', Monaco, monospace;
      font-size: 13px;
      color: var(--text-secondary);
      position: relative;
      border: 1px solid var(--border-medium);
      box-shadow: var(--shadow-sm);
    }

    .thinking-block::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg,
        transparent 0%,
        rgba(0, 0, 0, 0.01) 50%,
        transparent 100%);
      pointer-events: none;
    }

    .thinking-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      font-weight: 700;
      color: var(--text-primary);
      cursor: pointer;
      user-select: none;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 11px;
      transition: all 0.2s ease;
    }

    .thinking-header:hover {
      color: var(--text-secondary);
    }

    .thinking-toggle {
      font-size: 11px;
      color: var(--text-secondary);
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 6px;
      border: 1px solid var(--border-medium);
      transition: all 0.2s ease;
    }

    .thinking-toggle:hover {
      background: rgba(0, 0, 0, 0.08);
      color: var(--text-primary);
    }

    .thinking-content {
      white-space: pre-wrap;
      word-wrap: break-word;
      text-align: left;
      line-height: 1.7;
      color: var(--text-secondary);
    }

    .thinking-content.collapsed {
      display: none;
    }

    /* Response Text Styling */
    .response-text {
      line-height: 1.8;
      color: var(--text-primary);
    }

    .response-text p {
      margin-bottom: 16px;
    }

    .response-text p:last-child {
      margin-bottom: 0;
    }

    .response-text code {
      background: rgba(0, 0, 0, 0.05);
      color: var(--text-primary);
      padding: 3px 8px;
      border-radius: 6px;
      font-size: 13px;
      font-family: 'JetBrains Mono', Monaco, monospace;
      border: 1px solid var(--border-medium);
    }

    .response-text pre {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 12px;
      overflow-x: auto;
      margin: 16px 0;
      border: 1px solid var(--border-medium);
      box-shadow: var(--shadow-sm);
    }

    .response-text pre code {
      background: none;
      padding: 0;
      border: none;
      color: var(--text-secondary);
    }

    .response-text ul, .response-text ol {
      margin-left: 24px;
      margin-bottom: 16px;
    }

    .response-text li {
      margin-bottom: 8px;
    }

    .response-text blockquote {
      border-left: 3px solid var(--text-primary);
      padding-left: 16px;
      margin: 16px 0;
      color: var(--text-secondary);
      background: rgba(0, 0, 0, 0.03);
      padding: 12px 12px 12px 16px;
      border-radius: 8px;
    }

    .response-text h1, .response-text h2, .response-text h3 {
      font-family: 'Inter', sans-serif;
      font-weight: 700;
      margin-top: 24px;
      margin-bottom: 12px;
      color: var(--text-primary);
    }

    .response-text a {
      color: var(--text-primary);
      text-decoration: none;
      border-bottom: 2px solid var(--text-primary);
      transition: all 0.2s ease;
      font-weight: 600;
    }

    .response-text a:hover {
      color: var(--text-secondary);
      border-bottom-color: var(--text-secondary);
    }

    /* Streaming Indicator */
    .streaming-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin-top: 12px;
    }

    .streaming-indicator .dot {
      width: 8px;
      height: 8px;
      background: var(--accent-primary);
      border-radius: 50%;
      animation: dotPulse 1.4s ease-in-out infinite;
    }

    .streaming-indicator .dot:nth-child(2) {
      animation-delay: 0.2s;
    }

    .streaming-indicator .dot:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes dotPulse {
      0%, 100% {
        opacity: 0.3;
        transform: scale(0.8);
      }
      50% {
        opacity: 1;
        transform: scale(1.2);
      }
    }

    /* Modern Input Area */
    .input-container {
      border-top: 1px solid var(--border-medium);
      padding: 24px 32px;
      background: var(--surface-glass);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      position: relative;
      box-shadow: 0 -4px 16px rgba(0, 0, 0, 0.2);
    }

    .input-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: var(--gradient-border);
    }

    .input-form {
      display: flex;
      gap: 16px;
      align-items: flex-end;
    }

    #user-input {
      flex: 1;
      min-height: 56px;
      max-height: 200px;
      padding: 16px 20px;
      border: 2px solid var(--border-medium);
      border-radius: 12px;
      font-size: 15px;
      font-family: 'Inter', sans-serif;
      background: var(--bg-secondary);
      color: var(--text-primary);
      resize: none;
      outline: none;
      transition: all 0.3s ease;
      box-shadow: var(--shadow-sm);
    }

    #user-input::placeholder {
      color: var(--text-muted);
    }

    #user-input:focus {
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(30, 58, 95, 0.1), var(--shadow-md);
      background: var(--bg-tertiary);
    }

    /* Navy Button with Animation */
    #send-button {
      padding: 16px 32px;
      background: var(--gradient-primary);
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 15px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 100px;
      font-family: 'Space Grotesk', sans-serif;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: var(--shadow-md);
      position: relative;
      overflow: hidden;
    }

    #send-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s ease;
    }

    #send-button:hover:not(:disabled)::before {
      left: 100%;
    }

    #send-button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
      background: var(--gradient-accent);
    }

    #send-button:active:not(:disabled) {
      transform: translateY(0);
    }

    #send-button:disabled {
      background: var(--surface-elevated);
      color: var(--text-muted);
      cursor: not-allowed;
      box-shadow: none;
      border: 1px solid var(--border-medium);
    }

    /* Error Styling */
    .error-message {
      background: var(--error-bg);
      border: 1px solid var(--error);
      color: var(--error);
      padding: 16px 20px;
      border-radius: 12px;
      margin: 16px 0;
      font-size: 14px;
      font-family: 'JetBrains Mono', monospace;
      box-shadow: 0 4px 16px rgba(255, 107, 107, 0.2);
    }

    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 80px 32px;
      color: var(--text-secondary);
    }

    .empty-state h2 {
      font-family: 'Inter', sans-serif;
      font-size: 32px;
      margin-bottom: 16px;
      color: var(--text-primary);
      font-weight: 700;
    }

    .empty-state p {
      font-size: 16px;
      color: var(--text-muted);
    }

    /* Plan Docs File Upload Section - Modern Design */
    .files-section {
      border-bottom: 1px solid var(--border-medium);
      background: var(--surface-glass);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      position: relative;
    }

    .files-section::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: var(--gradient-border);
    }

    .files-header {
      display: flex;
      align-items: center;
      padding: 16px 32px;
      cursor: pointer;
      user-select: none;
      transition: all 0.3s ease;
    }

    .files-header:hover {
      background: rgba(0, 0, 0, 0.02);
    }

    .files-title {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 15px;
      font-weight: 700;
      color: var(--text-primary);
      font-family: 'Inter', sans-serif;
      letter-spacing: 0.3px;
    }

    .files-icon {
      display: flex;
      align-items: center;
      color: var(--text-secondary);
    }

    .files-icon svg {
      width: 20px;
      height: 20px;
    }

    .files-count {
      font-size: 13px;
      color: var(--text-muted);
      font-weight: 500;
      font-family: 'JetBrains Mono', monospace;
    }

    .files-toggle {
      font-size: 14px;
      color: var(--text-secondary);
      transition: transform 0.3s ease;
    }

    .files-toggle.collapsed {
      transform: rotate(-90deg);
    }

    .files-content {
      padding: 24px 32px 28px;
      max-height: 500px;
      overflow-y: auto;
      transition: max-height 0.3s ease-out, padding 0.3s ease-out;
    }

    .files-content::-webkit-scrollbar {
      width: 6px;
    }

    .files-content::-webkit-scrollbar-track {
      background: transparent;
    }

    .files-content::-webkit-scrollbar-thumb {
      background: var(--surface-elevated);
      border-radius: 3px;
    }

    .files-content.collapsed {
      max-height: 0;
      padding: 0 32px;
      overflow: hidden;
    }

    /* Modern Drop Zone */
    .drop-zone {
      border: 2px dashed var(--border-medium);
      border-radius: 16px;
      padding: 48px 32px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-bottom: 20px;
      background: var(--bg-secondary);
      position: relative;
      overflow: hidden;
    }

    .drop-zone::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--gradient-border);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .drop-zone:hover {
      border-color: var(--accent-primary);
      background: var(--bg-tertiary);
      box-shadow: var(--shadow-md);
    }

    .drop-zone:hover::before {
      opacity: 0.05;
    }

    .drop-zone.dragging {
      border-color: var(--accent-primary);
      background: rgba(30, 58, 95, 0.06);
      border-width: 3px;
      box-shadow: var(--shadow-glow);
    }

    .drop-zone-icon {
      margin-bottom: 12px;
      color: var(--text-muted);
    }

    .drop-zone-icon svg {
      width: 48px;
      height: 48px;
    }

    .drop-zone-text {
      font-size: 16px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 8px;
      font-family: 'Inter', sans-serif;
    }

    .drop-zone-hint {
      font-size: 13px;
      color: var(--text-muted);
      line-height: 1.6;
      font-family: 'JetBrains Mono', monospace;
    }

    .files-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* Modern File Cards */
    .file-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border-medium);
      border-radius: 12px;
      padding: 16px 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      transition: all 0.3s ease;
      animation: slideInUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      position: relative;
      overflow: hidden;
    }

    .file-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 3px;
      height: 100%;
      background: var(--gradient-primary);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .file-card:hover {
      border-color: var(--text-primary);
      box-shadow: var(--shadow-md);
      transform: translateX(4px);
    }

    .file-card:hover::before {
      opacity: 1;
    }

    .file-card.uploading {
      opacity: 0.7;
      animation: pulse 2s ease infinite;
    }

    .file-card.error {
      border-color: var(--error);
      background: var(--error-bg);
    }

    .file-card.error::before {
      background: var(--error);
      opacity: 1;
    }

    .file-icon {
      flex-shrink: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .file-icon svg {
      width: 28px;
      height: 28px;
    }

    .file-info {
      flex: 1;
      min-width: 0;
    }

    .file-name {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
      word-break: break-all;
      line-height: 1.5;
    }

    .file-meta {
      font-size: 12px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      font-family: 'JetBrains Mono', monospace;
    }

    .file-size {
      display: inline-flex;
      align-items: center;
    }

    .file-status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 600;
    }

    .file-status.uploaded {
      color: var(--accent-success);
    }

    .file-status.uploading {
      color: var(--text-secondary);
    }

    .file-status.loading {
      color: var(--accent-primary);
    }

    .file-status.metadata_only {
      color: var(--text-secondary);
      font-style: italic;
    }

    .file-status.error {
      color: var(--error);
    }

    .file-remove {
      flex-shrink: 0;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      border: 1px solid var(--border-medium);
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: all 0.3s ease;
    }

    .file-remove:hover {
      background: var(--error);
      color: white;
      border-color: var(--error);
      transform: scale(1.1);
      box-shadow: var(--shadow-md);
    }

    /* Initial Compare Button UI - Hero Style */
    .initial-prompt {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
    }

    .compare-button {
      width: 100%;
      max-width: 500px;
      padding: 20px 48px;
      background: var(--gradient-primary);
      color: white;
      border: none;
      border-radius: 16px;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      font-family: 'Space Grotesk', sans-serif;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: var(--shadow-lg);
      position: relative;
      overflow: hidden;
    }

    .compare-button::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      transform: translate(-50%, -50%);
      transition: width 0.6s ease, height 0.6s ease;
    }

    .compare-button:hover:not(:disabled)::before {
      width: 300px;
      height: 300px;
    }

    .compare-button:hover:not(:disabled) {
      transform: translateY(-4px) scale(1.02);
      box-shadow: var(--shadow-lg);
      background: var(--gradient-accent);
    }

    .compare-button:active:not(:disabled) {
      transform: translateY(-2px) scale(1);
    }

    .compare-button:disabled {
      background: var(--surface-elevated);
      color: var(--text-muted);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
      border: 1px solid var(--border-medium);
    }

    .compare-button.comparing {
      background: var(--gradient-accent);
      animation: pulse 2s ease infinite;
    }

    .helper-text {
      font-size: 14px;
      color: var(--text-secondary);
      text-align: center;
      margin: 0;
      font-family: 'JetBrains Mono', monospace;
    }

    .helper-text.warning {
      color: var(--text-primary);
      font-weight: 600;
    }

    /* Tab Interface for Three Outputs */
    .output-tabs {
      display: none; /* Hidden until comparison completes */
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

    .output-tabs.active {
      display: flex;
    }

    .tabs-header {
      display: flex;
      border-bottom: 2px solid var(--border-medium);
      background: var(--surface-glass);
      backdrop-filter: blur(12px);
      padding: 0 32px;
      gap: 8px;
    }

    .tab-button {
      padding: 16px 24px;
      background: none;
      border: none;
      border-bottom: 3px solid transparent;
      font-size: 14px;
      font-weight: 600;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Space Grotesk', sans-serif;
      position: relative;
    }

    .tab-button:hover {
      color: var(--accent-primary);
      background: rgba(30, 58, 95, 0.05);
    }

    .tab-button.active {
      color: var(--accent-primary);
      border-bottom-color: var(--accent-primary);
    }

    .tab-content {
      display: none;
      flex: 1;
      overflow-y: auto;
      padding: 32px;
    }

    .tab-content.active {
      display: block;
    }

    .tab-content::-webkit-scrollbar {
      width: 8px;
    }

    .tab-content::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }

    .tab-content::-webkit-scrollbar-thumb {
      background: var(--surface-elevated);
      border-radius: 4px;
    }

    /* Output Specific Styles */
    .output-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 2px solid var(--border-medium);
      /* Sticky header to prevent gap when scrolling */
      position: sticky;
      top: -32px;
      z-index: 15;
      background: var(--bg-primary);
      margin-top: 0;
      padding-top: 32px;
    }

    .output-title {
      font-family: 'Inter', sans-serif;
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
    }

    .download-button {
      padding: 12px 24px;
      background: var(--gradient-primary);
      color: white;
      border: none;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Space Grotesk', sans-serif;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .download-button:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
      background: var(--gradient-accent);
    }

    /* Summary Output Styles */
    .summary-content {
      font-size: 15px;
      line-height: 1.8;
    }

    .summary-content h2 {
      font-family: 'Inter', sans-serif;
      font-size: 20px;
      font-weight: 700;
      margin: 24px 0 12px 0;
      color: var(--text-primary);
    }

    .summary-content h3 {
      font-family: 'Inter', sans-serif;
      font-size: 16px;
      font-weight: 600;
      margin: 20px 0 10px 0;
      color: var(--text-secondary);
    }

    .summary-content ul {
      margin-left: 24px;
      margin-bottom: 16px;
    }

    .summary-content li {
      margin-bottom: 8px;
    }

    /* Table Styles for Spreadsheet Outputs */
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      background: var(--bg-primary);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: var(--shadow-md);
      margin-top: 16px;
    }

    .comparison-table thead {
      background: var(--gradient-primary);
      color: white;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .comparison-table th {
      padding: 14px;
      text-align: left;
      font-weight: 700;
      font-family: 'Inter', sans-serif;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .comparison-table td {
      padding: 12px 14px;
      border-bottom: 1px solid var(--border-subtle);
      font-size: 13px;
      vertical-align: top;
      line-height: 1.5;
    }

    .comparison-table tbody tr:hover {
      background: var(--bg-secondary);
    }

    .comparison-table tbody tr:last-child td {
      border-bottom: none;
    }

    /* First column (procedure element) styling */
    .comparison-table td:first-child {
      font-weight: 600;
      color: var(--text-primary);
      background: var(--bg-secondary);
      position: sticky;
      left: 0;
      z-index: 5;
    }

    /* Language Comparison Specific Styles */
    .language-row {
      margin-bottom: 40px;
      padding: 24px;
      background: var(--surface-glass);
      border-radius: 12px;
      border: 1px solid var(--border-medium);
    }

    .language-row-header {
      font-family: 'Inter', sans-serif;
      font-size: 18px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 2px solid var(--border-medium);
    }

    .plan-language {
      margin-bottom: 24px;
      padding: 16px;
      background: var(--bg-primary);
      border-radius: 8px;
      border-left: 3px solid var(--text-primary);
    }

    .plan-language:last-child {
      margin-bottom: 0;
    }

    .plan-name {
      font-weight: 700;
      font-size: 15px;
      color: var(--text-primary);
      margin-bottom: 8px;
      font-family: 'Inter', sans-serif;
    }

    .plan-summary {
      font-size: 13px;
      color: var(--text-secondary);
      font-style: italic;
      margin-bottom: 12px;
    }

    .plan-full-text {
      font-size: 14px;
      line-height: 1.7;
      color: var(--text-primary);
      margin-bottom: 10px;
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: 6px;
      font-family: 'JetBrains Mono', monospace;
    }

    .plan-citation {
      font-size: 12px;
      color: var(--text-muted);
      font-family: 'JetBrains Mono', monospace;
    }

    /* Table borders for markdown-rendered tables in output tabs */
    .tab-content table {
      border-collapse: collapse;
      width: 100%;
      margin: 16px 0;
    }

    /* Sticky table headers - keeps column labels visible while scrolling */
    .tab-content table thead {
      position: sticky;
      top: 50px;  /* Below the sticky output-header */
      z-index: 10;
      background: var(--bg-tertiary);
    }

    .tab-content table th,
    .tab-content table td {
      border: 1px solid var(--border-subtle);
      padding: 10px 12px;
      text-align: left;
      font-size: 13px;
      line-height: 1.5;
    }

    .tab-content table th {
      background: var(--bg-tertiary);
      font-weight: 600;
      color: var(--accent-primary);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .tab-content table tr:hover {
      background: rgba(30, 58, 95, 0.04);
    }

    /* Citation highlighting in Citations tab */
    .citation {
      background: rgba(30, 58, 95, 0.08);
      padding: 2px 4px;
      border-radius: 3px;
      font-size: 0.9em;
    }

    /* Clickable citation link */
    .citation-link {
      cursor: pointer;
      text-decoration: none;
      color: inherit;
      border-bottom: 1px dashed var(--accent-primary);
      transition: background 0.15s ease;
    }

    .citation-link:hover {
      background: rgba(30, 58, 95, 0.15);
      text-decoration: none;
    }

    /* Unmatched citation warning */
    .citation-unmatched {
      border-bottom: 1px dashed #b45309;
      cursor: help;
    }

    /* Citation loading (file being fetched from R2) */
    .citation-pending {
      border-bottom: 1px dashed #6b7280;
      cursor: wait;
      opacity: 0.7;
    }

    /* NFR/Proxy mode notice in Settings Modal */
    .settings-proxy-notice {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      background: rgba(30, 58, 95, 0.08);
      border: 1px solid rgba(30, 58, 95, 0.15);
      border-radius: 8px;
      font-size: 14px;
      color: var(--brand-navy);
      font-weight: 500;
    }
    .settings-proxy-notice svg {
      flex-shrink: 0;
      color: var(--brand-navy);
    }
    .settings-secured-display {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      color: var(--text-secondary);
    }
    .settings-secured-display svg {
      flex-shrink: 0;
    }

    /* Loading Indicator for Comparison (in messages area) */
    .comparison-loading-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 80px 32px;
      gap: 24px;
      min-height: 300px;
    }

    .comparison-loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid var(--border-subtle);
      border-top-color: var(--accent-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .comparison-loading-text {
      font-family: 'Inter', sans-serif;
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .comparison-loading-phase {
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: var(--text-secondary);
      text-align: center;
      max-width: 500px;
    }

    .comparison-progress-dots {
      display: flex;
      gap: 12px;
      margin-top: 8px;
    }

    .progress-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--border-subtle);
      transition: all 0.3s ease;
    }

    .progress-dot.active {
      background: var(--accent-primary);
      transform: scale(1.3);
    }

    /* Phase Progress Indicator (in tab bar) */
    .phase-progress {
      display: none;
      align-items: center;
      gap: 12px;
      padding: 8px 16px;
      margin-left: auto;
      background: var(--bg-secondary);
      border-radius: 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .phase-progress.active {
      display: flex;
    }

    .phase-dots-anim {
      display: inline-block;
      width: 1.5em;
      text-align: left;
    }

    .phase-dots {
      display: flex;
      gap: 6px;
    }

    .phase-dots .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--border-subtle);
      transition: all 0.3s ease;
    }

    .phase-dots .dot.active {
      background: var(--accent-primary);
      transform: scale(1.2);
      animation: phasePulse 1.5s ease-in-out infinite;
    }

    .phase-dots .dot.complete {
      background: #22c55e;
    }

    @keyframes phasePulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Split View Layout for Chat (Permanent Sidebar) */
    .split-view {
      display: none; /* Hidden by default */
      position: fixed;
      right: 0;
      top: 140px; /* Below header */
      height: calc(100vh - 140px);
      width: 48px; /* Start with collapsed width */
      z-index: 100;
      transition: width 0.3s ease;
    }

    .split-view.active {
      display: flex;
      flex-direction: row;
    }

    .split-view.expanded {
      /* Width controlled by inline styles for resize functionality */
    }

    /* Hide results-panel initially - only show when expanded with resize */
    .split-view .results-panel {
      display: none;
    }

    /* Show resize handle only when chat is expanded */
    .split-view .resize-handle {
      display: none;
    }

    .split-view.expanded .resize-handle {
      display: flex;
    }

    /* Adjust output-tabs to make room for chat sidebar */
    /* Margins are controlled via inline styles for resize functionality */

    /* Chat panel sizing */
    .split-view .chat-panel {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    /* Hide main chat content when collapsed */
    .split-view .chat-panel.collapsed .chat-messages-container,
    .split-view .chat-panel.collapsed .chat-input-area {
      display: none;
    }

    .results-panel {
      flex: 0 0 40%;
      border-right: 1px solid var(--border-medium);
      display: flex;
      flex-direction: column;
      background: var(--bg-secondary);
      overflow: hidden;
    }

    .mini-tabs {
      display: flex;
      gap: 4px;
      padding: 12px;
      border-bottom: 1px solid var(--border-subtle);
      background: var(--bg-tertiary);
      flex-shrink: 0;
    }

    .mini-tab {
      padding: 6px 14px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: 'Space Grotesk', sans-serif;
    }

    .mini-tab:hover {
      background: var(--surface-glass);
      color: var(--text-primary);
      border-color: var(--border-medium);
    }

    .mini-tab.active {
      background: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
    }

    .mini-output-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      background: var(--bg-primary);
    }

    .mini-output-content::-webkit-scrollbar {
      width: 6px;
    }

    .mini-output-content::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }

    .mini-output-content::-webkit-scrollbar-thumb {
      background: var(--surface-elevated);
      border-radius: 3px;
    }

    /* Chat Panel Styles */
    .chat-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--bg-primary);
      overflow: hidden;
    }

    .chat-messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .chat-messages-container::-webkit-scrollbar {
      width: 8px;
    }

    .chat-messages-container::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }

    .chat-messages-container::-webkit-scrollbar-thumb {
      background: var(--surface-elevated);
      border-radius: 4px;
    }

    .chat-message {
      animation: slideInUp 0.3s ease;
    }

    .chat-message.user {
      align-self: flex-end;
      max-width: 80%;
    }

    .chat-message.assistant {
      align-self: flex-start;
      max-width: 90%;
    }

    .chat-message-header {
      font-size: 11px;
      font-weight: 700;
      color: var(--text-secondary);
      font-family: 'JetBrains Mono', monospace;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 6px;
    }

    .chat-message-content {
      background: var(--surface-glass);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      padding: 16px 20px;
      border-radius: 12px;
      border: 1px solid var(--border-medium);
      box-shadow: var(--shadow-sm);
      transition: all 0.3s ease;
    }

    .chat-message.user .chat-message-content {
      background: rgba(0, 0, 0, 0.02);
      border-color: rgba(0, 0, 0, 0.15);
    }

    .chat-message-content:hover {
      box-shadow: var(--shadow-md);
      border-color: rgba(0, 0, 0, 0.2);
    }

    /* List styling for chat messages */
    .chat-message-content ul,
    .chat-message-content ol {
      margin: 8px 0;
      padding-left: 24px;
    }

    .chat-message-content li {
      margin: 6px 0;
      line-height: 1.5;
    }

    .chat-message-content ul {
      list-style-type: disc;
    }

    .chat-message-content ul ul {
      list-style-type: circle;
      margin: 4px 0;
    }

    .chat-message-content ul ul ul {
      list-style-type: square;
    }

    .chat-message-content li > p {
      margin: 0;
      display: inline;
    }

    .chat-input-area {
      padding: 16px 20px;
      border-top: 1px solid var(--border-medium);
      background: var(--bg-secondary);
      display: flex;
      gap: 12px;
      align-items: flex-end;
      flex-shrink: 0;
    }

    #chat-input {
      flex: 1;
      min-height: 44px;
      max-height: 150px;
      padding: 12px 16px;
      border: 1px solid var(--border-medium);
      border-radius: 10px;
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      line-height: 1.5;
      resize: none;
      transition: all 0.2s ease;
    }

    #chat-input:focus {
      outline: none;
      border-color: var(--text-primary);
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
    }

    #chat-input::placeholder {
      color: var(--text-muted);
    }

    #chat-send-button {
      padding: 12px 24px;
      background: var(--gradient-primary);
      color: white;
      border: none;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Space Grotesk', sans-serif;
      white-space: nowrap;
    }

    #chat-send-button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
      background: var(--gradient-accent);
    }

    #chat-send-button:disabled {
      background: var(--surface-elevated);
      color: var(--text-muted);
      cursor: not-allowed;
      transform: none;
    }

    .chat-streaming-indicator {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-top: 8px;
    }

    .chat-streaming-indicator .dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--text-secondary);
      animation: dotPulse 1.4s ease-in-out infinite;
    }

    .chat-streaming-indicator .dot:nth-child(2) {
      animation-delay: 0.2s;
    }

    .chat-streaming-indicator .dot:nth-child(3) {
      animation-delay: 0.4s;
    }

    .tab-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Coming Soon Tab Styling */
    .coming-soon-tab {
      color: #ff8c42 !important;
      border-bottom-color: #ffd4b3 !important;
      cursor: not-allowed;
      opacity: 0.7;
    }

    .coming-soon-tab:hover {
      color: #ff9e5f !important;
      border-bottom-color: #ffe0c7 !important;
    }

    /* Resize Handle for Split View */
    .resize-handle {
      flex: 0 0 4px;
      background: var(--bg-secondary);
      cursor: col-resize;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
    }

    .resize-handle:hover {
      background: var(--border-medium);
    }

    .resize-handle-line {
      width: 1px;
      height: 40px;
      background: var(--text-muted);
      border-radius: 2px;
      transition: background 0.2s ease;
    }

    .resize-handle:hover .resize-handle-line {
      background: var(--text-primary);
    }

    .resizing {
      cursor: col-resize !important;
      user-select: none;
    }

    .collapse-button {
      position: absolute;
      top: 12px;
      left: 8px;
      width: 32px;
      height: 32px;
      background: var(--surface-glass);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border-medium);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 14px;
      color: var(--text-primary);
      transition: all 0.2s ease;
      z-index: 1000;
    }

    .collapse-button:hover {
      background: var(--text-primary);
      color: white;
      transform: scale(1.1);
      border-color: var(--text-primary);
    }

    /* Hide collapse button when chat panel is collapsed */
    .chat-panel.collapsed .collapse-button {
      display: none;
    }

    .chat-panel-collapsed-ui {
      display: none;
      width: 100%;
      height: 100%;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 16px 0;
      background: var(--bg-tertiary);
    }

    .chat-panel.collapsed .chat-panel-collapsed-ui {
      display: flex;
    }

    .expand-chat-button {
      writing-mode: vertical-rl;
      text-orientation: mixed;
      padding: 16px 10px;
      background: var(--text-primary);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 1px;
      cursor: pointer;
      font-family: 'Space Grotesk', sans-serif;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .expand-chat-button:hover {
      background: var(--text-secondary);
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    /* Responsive Design - Mobile & Tablet */
    @media (max-width: 768px) {
      .chat-header {
        padding: 14px 24px;
      }

      .chat-header h1 {
        font-size: 22px;
      }

      .model-badge {
        padding: 6px 12px;
        font-size: 12px;
      }

      .thinking-indicator-badge {
        font-size: 10px;
        padding: 5px 10px;
      }

      .files-header {
        padding: 14px 24px;
      }

      .files-content {
        padding: 20px 24px 24px;
      }

      .drop-zone {
        padding: 36px 24px;
      }

      .drop-zone-icon svg {
        width: 40px;
        height: 40px;
      }

      .drop-zone-text {
        font-size: 15px;
      }

      .drop-zone-hint {
        font-size: 12px;
      }

      .file-card {
        padding: 14px 16px;
        gap: 12px;
      }

      .file-icon svg {
        width: 24px;
        height: 24px;
      }

      .file-name {
        font-size: 13px;
      }

      .file-meta {
        font-size: 11px;
      }

      .messages-container {
        padding: 24px 20px;
      }

      .message-content {
        padding: 20px;
      }

      .input-container {
        padding: 20px 24px;
      }

      #user-input {
        min-height: 52px;
        padding: 14px 18px;
        font-size: 14px;
      }

      #send-button {
        padding: 14px 28px;
        font-size: 14px;
        min-width: 90px;
      }

      .compare-button {
        max-width: 100%;
        padding: 18px 40px;
        font-size: 16px;
      }

      .empty-state {
        padding: 60px 24px;
      }

      .empty-state h2 {
        font-size: 26px;
      }

      .empty-state p {
        font-size: 15px;
      }
    }

    @media (max-width: 480px) {
      .chat-header {
        padding: 12px 20px;
      }

      .chat-header h1 {
        font-size: 18px;
      }

      .model-badge {
        padding: 5px 10px;
        font-size: 11px;
      }

      .files-header {
        padding: 12px 20px;
      }

      .files-content {
        padding: 16px 20px 20px;
      }

      .messages-container {
        padding: 20px 16px;
      }

      .message-content {
        padding: 16px;
      }

      .input-container {
        padding: 16px 20px;
      }

      #user-input {
        padding: 12px 16px;
        font-size: 14px;
      }

      #send-button {
        padding: 12px 24px;
        font-size: 13px;
        min-width: 80px;
      }

      .compare-button {
        padding: 16px 32px;
        font-size: 15px;
      }
    }

    /* Notes Feature Styles */
    .note-highlight {
      background: linear-gradient(180deg, rgba(255, 230, 100, 0.4), rgba(255, 230, 100, 0.3));
      border-bottom: 2px solid rgba(200, 160, 0, 0.6);
      cursor: pointer;
      padding: 1px 2px;
      border-radius: 2px;
      transition: all 0.2s ease;
    }
    .note-highlight:hover {
      background: rgba(255, 230, 100, 0.6);
      border-bottom-color: rgba(200, 160, 0, 0.9);
    }
    .note-highlight.active {
      background: rgba(255, 200, 50, 0.5);
      box-shadow: 0 0 0 2px rgba(200, 160, 0, 0.3);
    }

    .note-popup {
      position: fixed;
      z-index: 10001;
      width: 320px;
      max-height: 400px;
      background: var(--surface-glass);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid var(--border-medium);
      border-radius: 12px;
      box-shadow: var(--shadow-lg);
      animation: notePopupIn 0.2s ease;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    @keyframes notePopupIn {
      from {
        opacity: 0;
        transform: translateY(-8px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    .note-popup-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-subtle);
      background: var(--bg-tertiary);
      flex-shrink: 0;
    }
    .note-popup-title {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .note-popup-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .note-popup-btn {
      padding: 4px 8px;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .note-popup-btn.delete {
      background: rgba(220, 38, 38, 0.1);
      color: #dc2626;
    }
    .note-popup-btn.delete:hover {
      background: #dc2626;
      color: white;
    }
    .note-popup-close {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    .note-popup-close:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }
    .note-popup-content {
      padding: 16px;
      max-height: 350px;
      overflow-y: auto;
      flex-grow: 1;
    }
    .note-popup-content.editing {
      padding: 12px;
    }
    .note-editor {
      width: 100%;
      min-height: 100px;
      padding: 12px;
      border: 1px solid var(--border-medium);
      border-radius: 8px;
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      line-height: 1.5;
      resize: vertical;
      box-sizing: border-box;
    }
    .note-editor:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(30, 58, 95, 0.1);
    }
    .note-rendered {
      font-size: 14px;
      line-height: 1.6;
      color: var(--text-primary);
    }
    .note-rendered p {
      margin: 0 0 8px 0;
    }
    .note-rendered p:last-child {
      margin-bottom: 0;
    }
    .note-popup-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      padding: 12px 16px;
      border-top: 1px solid var(--border-subtle);
      background: var(--bg-tertiary);
      flex-shrink: 0;
    }
    .note-save-btn {
      padding: 8px 16px;
      background: var(--gradient-primary);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .note-save-btn:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }
    .note-cancel-btn {
      padding: 8px 16px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border-medium);
      border-radius: 8px;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .note-cancel-btn:hover {
      background: var(--surface-glass);
    }
    .note-timestamp {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 12px;
      font-family: 'JetBrains Mono', monospace;
    }
    .note-edit-btn {
      background: none;
      border: none;
      color: var(--accent-primary);
      cursor: pointer;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    .note-edit-btn:hover {
      background: rgba(30, 58, 95, 0.1);
    }

    /* Note author display */
    .note-author {
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }

    /* Note actions row */
    .note-actions {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }
    .note-reply-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    .note-reply-btn:hover {
      background: rgba(30, 58, 95, 0.1);
      color: var(--accent-primary);
    }

    /* Reply divider */
    .note-reply-divider {
      font-size: 12px;
      color: var(--text-secondary);
      margin: 12px 0 8px 0;
      padding-top: 8px;
      border-top: 1px solid var(--border);
    }

    /* Reply editor */
    .reply-editor {
      min-height: 60px;
    }

    /* Replies section */
    .note-replies {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }
    .replies-header {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }
    .note-reply {
      background: rgba(30, 58, 95, 0.05);
      border-radius: 6px;
      padding: 8px 10px;
      margin-bottom: 8px;
    }
    .note-reply:last-child {
      margin-bottom: 0;
    }
    .reply-author {
      font-size: 10px;
      color: var(--accent-primary);
      font-weight: 500;
      margin-bottom: 4px;
    }
    .reply-content {
      font-size: 12px;
      line-height: 1.4;
    }
    .reply-content p {
      margin: 0;
    }
    .reply-meta {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 4px;
    }
    .reply-timestamp {
      font-size: 10px;
      color: var(--text-tertiary);
    }
    .reply-delete-btn {
      background: none;
      border: none;
      color: var(--text-tertiary);
      cursor: pointer;
      font-size: 10px;
      padding: 2px 4px;
      border-radius: 3px;
      transition: all 0.2s ease;
    }
    .reply-delete-btn:hover {
      background: rgba(220, 53, 69, 0.1);
      color: #dc3545;
    }

    /* Selection hint tooltip */
    .selection-hint {
      position: fixed;
      z-index: 10000;
      padding: 4px 8px;
      background: var(--text-primary);
      border-radius: 6px;
      animation: fadeIn 0.15s ease;
      box-shadow: var(--shadow-md);
    }
    .selection-hint button {
      background: none;
      border: none;
      color: white;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      padding: 4px 8px;
      white-space: nowrap;
    }
    .selection-hint button:hover {
      text-decoration: underline;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
  </style>
</head>
<body>
  <div class="chat-container">
    <header class="chat-header">
      <h1>
        <svg class="logo-icon" viewBox="0 0 24 24" width="28" height="28">
          <rect x="2" y="2" width="5" height="5" rx="1" fill="currentColor"/>
          <rect x="9.5" y="2" width="5" height="5" rx="1" fill="currentColor" opacity="0.7"/>
          <rect x="17" y="2" width="5" height="5" rx="1" fill="currentColor"/>
          <rect x="2" y="9.5" width="5" height="5" rx="1" fill="currentColor" opacity="0.7"/>
          <rect x="9.5" y="9.5" width="5" height="5" rx="1" fill="currentColor"/>
          <rect x="17" y="9.5" width="5" height="5" rx="1" fill="currentColor" opacity="0.7"/>
          <rect x="2" y="17" width="5" height="5" rx="1" fill="currentColor"/>
          <rect x="9.5" y="17" width="5" height="5" rx="1" fill="currentColor" opacity="0.7"/>
          <rect x="17" y="17" width="5" height="5" rx="1" fill="currentColor"/>
        </svg>
        SPD MATRIX
      </h1>
      <div class="header-buttons">
        <button id="share-button" class="settings-button share-button" onclick="ChatApp.openShareModal()" title="Share" style="display: none;">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="18" cy="5" r="3"></circle>
            <circle cx="6" cy="12" r="3"></circle>
            <circle cx="18" cy="19" r="3"></circle>
            <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
          </svg>
        </button>
        <button class="settings-button history-button" onclick="ChatApp.toggleHistoryPanel()" title="History">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10"></circle>
            <polyline points="12 6 12 12 16 14"></polyline>
          </svg>
          <span id="history-badge" class="history-badge" style="display: none;">0</span>
        </button>
        <button class="settings-button" onclick="ChatApp.showApiKeyModal()" title="Settings">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="3"></circle>
          <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
      </button>
      </div>
    </header>

    <!-- History Panel (slide-in drawer) -->
    <div id="history-panel" class="history-panel">
      <div class="history-panel-header">
        <h3>History</h3>
        <button class="history-close-button" onclick="ChatApp.toggleHistoryPanel()">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <button id="new-analysis-button" class="new-analysis-button" onclick="ChatApp.startNewAnalysis()" style="display: none;">
        <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="12" y1="5" x2="12" y2="19"></line>
          <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
        New Analysis
      </button>
      <div id="history-content" class="history-content">
        <!-- Populated by renderHistoryPanel() -->
      </div>
    </div>

    <!-- Rename Modal -->
    <div id="rename-modal" class="modal-overlay" style="display: none;" onclick="ChatApp.closeRenameModal()">
      <div class="modal" onclick="event.stopPropagation()">
        <h2>Rename Analysis</h2>
        <input type="text" id="rename-input" placeholder="Enter new name"
               onkeydown="if(event.key === 'Enter') ChatApp.confirmRename()">
        <div class="modal-buttons">
          <button class="modal-button secondary" onclick="ChatApp.closeRenameModal()">Cancel</button>
          <button class="modal-button primary" onclick="ChatApp.confirmRename()">Save</button>
        </div>
      </div>
    </div>

    <!-- Share Modal -->
    <div id="share-modal" class="modal-overlay" style="display: none;" onclick="ChatApp.closeShareModal()">
      <div class="share-modal" onclick="event.stopPropagation()">
        <div class="share-modal-header">
          <h2>Share Analysis</h2>
          <button class="modal-close-btn" onclick="ChatApp.closeShareModal()">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
        <div class="share-modal-content">
          <!-- Email Share Section -->
          <div class="share-section">
            <h3>Share by Email</h3>
            <div class="share-email-input">
              <input type="email" id="share-email" placeholder="Enter email address"
                     onkeydown="if(event.key === 'Enter') ChatApp.addEmailShare()">
              <button onclick="ChatApp.addEmailShare()">Share</button>
            </div>
            <div id="email-shares-list" class="shares-list"></div>
          </div>
          <!-- Link Share Section -->
          <div class="share-section">
            <h3>Share by Link</h3>
            <p class="share-hint">Anyone with the link can view and add notes</p>
            <button onclick="ChatApp.createShareLink()" class="create-link-btn">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
              </svg>
              Generate Shareable Link
            </button>
            <div id="link-shares-list" class="shares-list"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Note Popup -->
    <div id="note-popup" class="note-popup" style="display: none;">
      <div class="note-popup-header">
        <span class="note-popup-title">Note</span>
        <div class="note-popup-actions">
          <button class="note-popup-btn delete" onclick="ChatApp.deleteCurrentNote()" title="Delete note">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="3 6 5 6 21 6"></polyline>
              <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
          </button>
          <button class="note-popup-close" onclick="ChatApp.closeNotePopup()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
      </div>
      <div class="note-popup-content" id="note-popup-content">
        <!-- Content rendered here (either editor or markdown view) -->
      </div>
      <div class="note-popup-footer" id="note-popup-footer">
        <button class="note-cancel-btn" onclick="ChatApp.cancelNoteEdit()">Cancel</button>
        <button class="note-save-btn" onclick="ChatApp.saveCurrentNote()">Save</button>
      </div>
    </div>

    <!-- Selection Hint (appears when text is selected) -->
    <div id="selection-hint" class="selection-hint" style="display: none;">
      <button onclick="ChatApp.addNoteFromSelection()">+ Add Note</button>
    </div>

    <!-- Settings Modal (adapts to local vs proxy mode) -->
    <div id="api-key-modal" class="modal-overlay" style="display: none;" onclick="ChatApp.handleModalClick(event)">
      <div class="modal" onclick="event.stopPropagation()">
        <h2>Settings</h2>

        <!-- Proxy Mode Content (shown when API key is server-side) -->
        <div id="settings-proxy-mode" style="display: none;">
          <div class="settings-proxy-notice">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="12" y1="16" x2="12" y2="12"></line>
              <line x1="12" y1="8" x2="12.01" y2="8"></line>
            </svg>
            <span>API key provided for this instance</span>
          </div>
          <p style="margin-top: 16px; color: var(--text-secondary);">This instance is pre-configured with a Gemini API key.</p>

          <label>Gemini API Key</label>
          <div class="settings-secured-display">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
              <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
            </svg>
            <span>Secured server-side</span>
          </div>

          <div class="modal-buttons">
            <button class="modal-button primary" onclick="ChatApp.closeApiKeyModal()">Close</button>
          </div>
        </div>

        <!-- Local Mode Content (shown when user provides API key) -->
        <div id="settings-local-mode" style="display: none;">
          <p>This application uses Gemini 3 Pro. Enter your API key below to get started.</p>

          <label for="api-key-input">Gemini API Key</label>
          <input type="password" id="api-key-input" placeholder="AIza..." onkeypress="if(event.key === 'Enter') ChatApp.saveApiKey()" />
          <div class="api-key-hint">
            Get your API key from <a href="https://aistudio.google.com/app/apikey" target="_blank">Google AI Studio</a>
          </div>

          <div class="modal-buttons">
            <button class="modal-button secondary" onclick="ChatApp.closeApiKeyModal()">Cancel</button>
            <button class="modal-button primary" onclick="ChatApp.saveApiKey()">Save Key</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Plan Docs File Upload Section -->
    <section class="files-section" id="files-section">
      <div class="files-header" onclick="ChatApp.toggleFilesPanel()">
        <div class="files-title">
          <span class="files-icon">
            <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
            </svg>
          </span>
          <span>Plan Docs</span>
          <span class="files-count" id="files-count">(0 files)</span>
          <span class="files-toggle" id="files-toggle">‚ñº</span>
        </div>
      </div>

      <div class="files-content" id="files-content">
        <div class="drop-zone" id="drop-zone">
          <input type="file" id="file-input" multiple accept=".pdf,.txt,.docx,.doc,.csv,.xlsx,.xls,image/*" hidden>
          <div class="drop-zone-content">
            <div class="drop-zone-icon">
              <svg viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14 2 14 8 20 8"/>
                <line x1="12" y1="18" x2="12" y2="12"/>
                <polyline points="9 15 12 12 15 15"/>
              </svg>
            </div>
            <div class="drop-zone-text">Drop files here or click to browse</div>
            <div class="drop-zone-hint">Supports PDF, DOCX, TXT, CSV, Excel, and images ‚Ä¢ Max 1,000 pages per PDF ‚Ä¢ 20 MB inline limit</div>
          </div>
        </div>

        <div class="files-list" id="files-list">
          <!-- File cards will be dynamically added here -->
        </div>
      </div>
    </section>

    <div class="messages-container" id="messages">
      <div class="empty-state">
        <h2>Ready to compare plan documents</h2>
        <p>Upload your PDF files above and click "Compare Documents" to begin analysis.</p>
      </div>
    </div>

    <!-- Three-Output Tab Interface (shown after comparison) -->
    <div class="output-tabs" id="output-tabs">
      <div class="tabs-header">
        <button class="tab-button active" onclick="ChatApp.switchTab('summary')">
          Summary
        </button>
        <button class="tab-button" onclick="ChatApp.switchTab('comparison')">
          Comparison Spreadsheet
        </button>
        <button class="tab-button" onclick="ChatApp.switchTab('language')">
          Citations
        </button>
        <button class="tab-button coming-soon-tab" disabled title="Additional features coming soon">
          Coming Soon
        </button>
        <!-- Phase progress indicator (shown during streaming) -->
        <div class="phase-progress" id="phase-progress">
          <span class="phase-text" id="phase-text">Reading to understand</span><span class="phase-dots-anim" id="phase-dots-anim">...</span>
          <div class="phase-dots">
            <span class="dot" id="pdot-1"></span>
            <span class="dot" id="pdot-2"></span>
            <span class="dot" id="pdot-3"></span>
          </div>
        </div>
      </div>

      <!-- Tab 1: Summary -->
      <div class="tab-content active" id="tab-summary">
        <div class="output-header">
          <h2 class="output-title">Summary</h2>
          <button class="download-button" id="download-summary-btn" onclick="ChatApp.downloadSummary()" style="display: none;">
            Download
          </button>
        </div>
        <div class="summary-content" id="summary-output"></div>
      </div>

      <!-- Tab 2: Comparison Spreadsheet -->
      <div class="tab-content" id="tab-comparison">
        <div class="output-header">
          <h2 class="output-title">Comparison Spreadsheet</h2>
          <button class="download-button" id="download-comparison-btn" onclick="ChatApp.downloadComparisonSpreadsheet()" style="display: none;">
            Download
          </button>
        </div>
        <div id="comparison-output"></div>
      </div>

      <!-- Tab 3: Citations -->
      <div class="tab-content" id="tab-language">
        <div class="output-header">
          <h2 class="output-title">Citations</h2>
          <button class="download-button" id="download-language-btn" onclick="ChatApp.downloadLanguageComparison()" style="display: none;">
            Download
          </button>
        </div>
        <div id="language-output"></div>
      </div>
    </div>

    <!-- Split View for Chat (shown when chat tab is active) -->
    <div class="split-view" id="split-view">
      <!-- Left panel: Results -->
      <div class="results-panel">
        <div class="mini-tabs">
          <button class="mini-tab" data-result="summary" onclick="ChatApp.switchMiniResultTab('summary')">Summary</button>
          <button class="mini-tab active" data-result="comparison" onclick="ChatApp.switchMiniResultTab('comparison')">Comparison</button>
          <button class="mini-tab" data-result="language" onclick="ChatApp.switchMiniResultTab('language')">Citations</button>
        </div>
        <div class="mini-output-content" id="mini-output-content"></div>
      </div>

      <!-- Resize Handle -->
      <div class="resize-handle" id="resize-handle">
        <div class="resize-handle-line"></div>
      </div>

      <!-- Right panel: Chat -->
      <div class="chat-panel" id="chat-panel">
        <!-- Collapse button (shown when expanded) -->
        <button class="collapse-button" id="collapse-chat-button" title="Collapse chat panel">
          ‚ñ∂
        </button>

        <div class="chat-messages-container" id="chat-messages"></div>
        <div class="chat-input-area">
          <textarea id="chat-input" placeholder="Ask about the analysis..." rows="1"></textarea>
          <button id="chat-send-button">Send</button>
        </div>

        <!-- Collapsed state UI -->
        <div class="chat-panel-collapsed-ui">
          <button class="expand-chat-button" onclick="ChatApp.toggleChatPanel()">
            Chat
          </button>
        </div>
      </div>
    </div>

    <div class="input-container">
      <form class="input-form" id="chat-form">
        <textarea
          id="user-input"
          placeholder="Ask anything..."
          rows="1"
          autofocus
        ></textarea>
        <button type="submit" id="send-button">Send</button>
      </form>
    </div>
  </div>

  <!-- Load config if available (local development) -->
  <script src="config.js" onerror="window.CONFIG_LOAD_FAILED = true;"></script>

  <script>
    // Ensure CONFIG exists with defaults
    if (typeof CONFIG === 'undefined' || window.CONFIG_LOAD_FAILED) {
      window.CONFIG = {
        MODEL: 'gemini-3-pro-preview',
        MAX_OUTPUT_TOKENS: 32768,
        THINKING_LEVEL: 'high'
      };
    }

    // Detect proxy mode by hostname (more reliable than checking for API key)
    // Local development: localhost, 127.0.0.1, file:// protocol
    // Cloudflare/Production: everything else uses server-side proxy
    const IS_LOCAL_DEV = window.location.hostname === 'localhost' ||
                         window.location.hostname === '127.0.0.1' ||
                         window.location.protocol === 'file:';
    const IS_PROXY_MODE = !IS_LOCAL_DEV;

    // Configure marked for markdown rendering
    marked.setOptions({
      breaks: true,
      gfm: true,
      headerIds: false,
      highlight: function(code, lang) {
        if (Prism.languages[lang]) {
          return Prism.highlight(code, Prism.languages[lang], lang);
        }
        return code;
      }
    });

    // Three Prompt Templates for Sequential API Calls
    const PROMPT_TEMPLATES = {
      phase1: (fileList) => {
        return `Comprehensively read all of the attached documents. You must return an organized overview of which documents are which, how they relate to one another, and the general domain, content, and structure of each.

The uploaded documents are (in order):
${fileList}

When referencing documents, use these EXACT filenames as provided above.

Return ONLY the organized overview with no preamble or footnotes. Be as concise as possible without oversimplifying. Maximum 500 words response.`;
      },

      phase2: (summaryResponse, fileList) => {
        return `Comprehensively read and analyze all of the attached documents. Here is a summary of the documents' content and structure:

<summary>
${summaryResponse}
</summary>

The uploaded documents are (in order):
${fileList}

I want you to return a detailed and comprehensive table comparing elements across all plans. Columns should represent identified plans, and rows should represent identified procedural elements within the plans. The purpose of this table is to compare procedural elements across all plan documents at a glance.

When naming columns or referencing documents, use the EXACT filenames as provided above.

Return ONLY the comparison table with no preamble, introduction, or footnotes. Do not oversimplify. Do not condense. Complete this task as comprehensively and completely as possible.`;
      },

      phase3: (summaryResponse, comparisonResponse, fileList) => {
        return `Comprehensively read and analyze all of the attached documents. Here is a summary of the documents' content and structure:

<summary>
${summaryResponse}
</summary>

Here is a table comparing the various procedural elements by plan:

<comparison>
${comparisonResponse}
</comparison>

The uploaded documents are (in order):
${fileList}

I want you to create a more detailed version of this table which fully quotes and cites the language from each and every document which represents the procedural elements being compared. The purpose of this is to facilitate quick analysis of the plan document changes and amendments over time while citing the specific language applicable in as detailed a manner as possible.

IMPORTANT: Your citations MUST use the EXACT filenames listed above. Do NOT invent, abbreviate, or modify filenames. Citations must be in parentheses behind each and every statement cited in the format: (filename, page_number, paragraph_number).

Return ONLY the detailed comparison table with no preamble, introduction, or footnotes. Do not oversimplify. Do not condense. Complete this task as comprehensively and completely as possible.`;
      }
    };

    // Phase Progress Messages - Contextual phrases that rotate during analysis
    const PHASE_MESSAGES = {
      1: [
        "Reading document contents",
        "Identifying plan structures",
        "Analyzing document relationships",
        "Scanning for key provisions",
        "Mapping document hierarchy",
        "Understanding plan types",
        "Reviewing benefit summaries",
        "Categorizing plan documents",
        "Processing document metadata",
        "Building document overview"
      ],
      2: [
        "Comparing plan provisions",
        "Analyzing key differences",
        "Cross-referencing documents",
        "Building comparison matrix",
        "Identifying variations",
        "Evaluating procedural elements",
        "Mapping similarities",
        "Synthesizing findings",
        "Organizing comparisons",
        "Structuring results"
      ],
      3: [
        "Extracting exact language",
        "Locating source references",
        "Compiling detailed quotes",
        "Verifying citations",
        "Cross-checking sources",
        "Documenting variations",
        "Finalizing references",
        "Building language table",
        "Validating quotations",
        "Completing detailed analysis"
      ]
    };

    // Chat Application
    const ChatApp = {
      state: {
        messages: [],
        isStreaming: false,
        currentThinking: '',
        currentResponse: '',
        currentBlockType: null,
        abortController: null,
        uploadedFiles: [],
        filesPanelExpanded: true,
        // Three-phase response tracking
        currentPhase: 0, // 0 = not started, 1-3 = active phase
        summaryResponse: null, // Phase 1 result
        comparisonResponse: null, // Phase 2 result
        languageResponse: null, // Phase 3 result
        activeTab: 'summary', // Current active tab
        isComparisonRequest: false, // Track if this is a comparison vs. regular chat
        // Chat-specific state
        chatMessages: [], // [{role, content, timestamp}]
        isChatStreaming: false, // Separate from main isStreaming
        currentChatResponse: '', // Accumulator for chat streaming
        chatPanelResultTab: 'comparison', // Which result to show in left panel
        // Split view state
        splitPanelWidth: 40, // Percentage for results panel (default 40%)
        isResizing: false, // Track if user is dragging resize handle
        chatPanelCollapsed: true, // Track if chat panel is collapsed (default: collapsed)
        chatPanelWidth: 400, // Width of chat panel in pixels when expanded
        // API key management
        sessionApiKey: null, // API key from modal (session only)
        // Progress message rotation
        progressMessageIndex: 0,
        progressMessageInterval: null,
        dotAnimationIndex: 0,
        dotAnimationInterval: null,
        // Blob URL cache for PDF viewing
        blobUrlCache: {},
        // Session history state
        currentAnalysisId: null,      // UUID of current/loaded analysis
        historyList: [],              // [{id, title, created_at, file_metadata}]
        historyPanelOpen: false,      // History drawer visibility
        renamingAnalysisId: null,     // ID of analysis being renamed
        // Notes state
        notes: [],                    // [{id, tab, anchor_text, anchor_prefix, anchor_suffix, content, created_at, author_email, replies}]
        activeNoteId: null,           // Currently open popup note ID
        pendingSelection: null,       // {text, prefix, suffix, tab, rect} - temp selection before note created
        isNotePopupOpen: false,       // Popup visibility state
        notePopupPosition: { top: 0, left: 0 }, // Popup positioning
        editingNoteContent: '',       // Current content in note editor
        isEditingNote: false,         // Whether we're in edit mode
        replyingToNoteId: null,       // Currently replying to this note
        replyContent: '',             // Reply editor content
        // Session sharing state
        isOwner: true,                // Is current user the owner of loaded analysis?
        ownerEmail: null,             // Owner's email (for shared analyses)
        currentUserEmail: null,       // Authenticated user's email
        shareModalOpen: false,        // Share modal visibility
        currentShares: { email_shares: [], link_shares: [] }, // Current analysis shares
        shareInputEmail: '',          // Email input in share modal
        sharedAnalysesList: []        // List of analyses shared with this user
      },

      init() {
        this.renderInputArea();
        this.initFileUpload();
        this.loadSessionApiKey();
        this.loadSplitViewPreferences();
        this.loadHistoryList();
        this.initNoteEvents();
        this.handleShareToken();
      },

      // Handle share token from URL (?share=TOKEN)
      async handleShareToken() {
        const urlParams = new URLSearchParams(window.location.search);
        const shareToken = urlParams.get('share');
        if (!shareToken) return;

        try {
          // Validate token
          const validateRes = await fetch(`/api/share/${shareToken}`);
          const validateData = await validateRes.json();

          if (!validateData.valid) {
            const errorMessages = {
              'not_found': 'This share link is invalid.',
              'expired': 'This share link has expired.',
              'revoked': 'This share link has been revoked.',
              'max_uses_reached': 'This share link has reached its maximum uses.'
            };
            alert(errorMessages[validateData.error] || 'Invalid share link.');
            window.history.replaceState({}, '', '/');
            return;
          }

          // Claim the share
          const claimRes = await fetch(`/api/share/${shareToken}`, { method: 'POST' });
          const claimData = await claimRes.json();

          if (claimData.success) {
            // Clear URL and load the analysis
            window.history.replaceState({}, '', '/');
            await this.loadAnalysis(claimData.analysis_id);
            // Refresh history to show the new shared analysis
            await this.loadHistoryList();
          } else {
            alert('Failed to access shared analysis.');
            window.history.replaceState({}, '', '/');
          }
        } catch (error) {
          console.error('Error handling share token:', error);
          alert('Error accessing shared analysis.');
          window.history.replaceState({}, '', '/');
        }
      },

      // Helper to generate formatted list of uploaded filenames for prompt injection
      getUploadedFileList() {
        return this.state.uploadedFiles
          .filter(f => f.status === 'uploaded')
          .map((f, i) => `${i + 1}. "${f.filename}"`)
          .join('\n');
      },

      loadSplitViewPreferences() {
        // Load saved split panel width
        const savedWidth = localStorage.getItem('splitPanelWidth');
        if (savedWidth) {
          this.state.splitPanelWidth = parseFloat(savedWidth);
        }

        // Load saved collapse state
        const savedCollapsed = localStorage.getItem('chatPanelCollapsed');
        if (savedCollapsed === 'true') {
          this.state.chatPanelCollapsed = true;
        }

        // Load saved chat panel width
        const savedChatWidth = localStorage.getItem('chatPanelWidth');
        if (savedChatWidth) {
          this.state.chatPanelWidth = parseFloat(savedChatWidth);
        }
      },

      // API Key Modal Functions
      showApiKeyModal() {
        const modal = document.getElementById('api-key-modal');
        const proxyContent = document.getElementById('settings-proxy-mode');
        const localContent = document.getElementById('settings-local-mode');

        // Show appropriate content based on mode
        if (IS_PROXY_MODE) {
          proxyContent.style.display = 'block';
          localContent.style.display = 'none';
        } else {
          proxyContent.style.display = 'none';
          localContent.style.display = 'block';
          const input = document.getElementById('api-key-input');
          // Pre-fill with session key if exists
          if (this.state.sessionApiKey) {
            input.value = this.state.sessionApiKey;
          }
          setTimeout(() => input.focus(), 100);
        }

        modal.style.display = 'flex';
      },

      closeApiKeyModal() {
        document.getElementById('api-key-modal').style.display = 'none';
      },

      handleModalClick(event) {
        // Close modal when clicking on overlay (outside the modal box)
        if (event.target.id === 'api-key-modal') {
          this.closeApiKeyModal();
        }
      },

      saveApiKey() {
        const input = document.getElementById('api-key-input');
        const apiKey = input.value.trim();

        if (!apiKey) {
          alert('Please enter an API key');
          return;
        }

        if (!apiKey.startsWith('AIza')) {
          alert('Invalid API key format. Gemini API keys start with "AIza"');
          return;
        }

        // Store in session storage
        sessionStorage.setItem('gemini_api_key', apiKey);
        this.state.sessionApiKey = apiKey;

        console.log('‚úÖ API Key saved to session');
        this.closeApiKeyModal();
      },

      loadSessionApiKey() {
        const savedKey = sessionStorage.getItem('gemini_api_key');
        if (savedKey) {
          this.state.sessionApiKey = savedKey;
          console.log('‚úÖ API Key loaded from session');
        }
      },

      getApiKey() {
        // Use session key if available, otherwise fall back to config.js
        return this.state.sessionApiKey || CONFIG.GEMINI_API_KEY;
      },

      // Get API endpoint URL based on mode
      getApiUrl(model) {
        if (IS_PROXY_MODE) {
          return `/api/gemini/${model}`;
        }
        return `https://generativelanguage.googleapis.com/v1beta/models/${model}:streamGenerateContent?alt=sse`;
      },

      // Get API headers based on mode
      getApiHeaders() {
        const headers = { 'Content-Type': 'application/json' };
        if (!IS_PROXY_MODE) {
          headers['x-goog-api-key'] = this.getApiKey();
        }
        return headers;
      },

      isInitialState() {
        return this.state.messages.length === 0;
      },

      renderInputArea() {
        const inputContainer = document.querySelector('.input-container');

        if (this.isInitialState()) {
          const hasFiles = this.state.uploadedFiles.filter(f => f.status === 'uploaded').length > 0;
          const isUploading = this.state.uploadedFiles.some(f => f.status === 'uploading');

          let helperText, helperClass, buttonDisabled;

          if (isUploading) {
            helperText = 'Waiting for files to finish uploading...';
            helperClass = 'warning';
            buttonDisabled = true;
          } else if (!hasFiles) {
            helperText = 'Upload plan documents above to begin comparison';
            helperClass = '';
            buttonDisabled = true;
          } else {
            helperText = 'Click to compare uploaded plan documents';
            helperClass = '';
            buttonDisabled = false;
          }

          inputContainer.innerHTML = `
            <div class="initial-prompt">
              <button
                type="button"
                id="compare-button"
                class="compare-button"
                ${buttonDisabled ? 'disabled' : ''}
              >
                Compare Documents
              </button>
              <p class="helper-text ${helperClass}" id="compare-helper">
                ${helperText}
              </p>
            </div>
          `;

          this.attachCompareButtonHandler();
        } else {
          // Hide input area after comparison starts - workflow uses Compare Documents button only
          inputContainer.style.display = 'none';
        }
      },

      attachCompareButtonHandler() {
        const compareButton = document.getElementById('compare-button');
        if (compareButton) {
          compareButton.addEventListener('click', () => {
            if (!this.state.isStreaming && !compareButton.disabled) {
              // Auto-collapse Plan Docs section
              if (this.state.filesPanelExpanded) {
                this.toggleFilesPanel();
              }
              // Mark this as a comparison request (not regular chat)
              this.state.isComparisonRequest = true;
              this.sendMessage('Compare the attached plan documents.');
            }
          });
        }
      },

      setupEventListeners() {
        const form = document.getElementById('chat-form');
        const input = document.getElementById('user-input');

        form.addEventListener('submit', (e) => {
          e.preventDefault();
          const message = input.value.trim();
          if (message && !this.state.isStreaming) {
            this.sendMessage(message);
            input.value = '';
            input.style.height = 'auto';
          }
        });

        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            form.dispatchEvent(new Event('submit'));
          }
        });

        input.addEventListener('input', () => {
          input.style.height = 'auto';
          input.style.height = Math.min(input.scrollHeight, 200) + 'px';
        });
      },

      autoResizeTextarea() {
        const input = document.getElementById('user-input');
        input.style.height = 'auto';
        input.style.height = input.scrollHeight + 'px';
      },

      addMessage(role, content, thinking = '') {
        this.state.messages.push({
          role,
          content,
          thinking
        });
        this.render();
      },

      async sendMessage(userMessage) {
        // Check if any files are still uploading
        const uploadingFiles = this.state.uploadedFiles.filter(f => f.status === 'uploading');
        if (uploadingFiles.length > 0) {
          alert('Please wait for all files to finish uploading before sending a message.');
          return;
        }

        // Track if this was the initial state
        const wasInitialState = this.isInitialState();

        // Clear empty state
        const messagesContainer = document.getElementById('messages');
        const emptyState = messagesContainer.querySelector('.empty-state');
        if (emptyState) {
          emptyState.remove();
        }

        // Add user message
        this.addMessage('user', userMessage);

        // Transition UI if this was the first message
        if (wasInitialState) {
          this.renderInputArea();
        }

        // For comparison requests, run three-phase analysis
        if (this.state.isComparisonRequest) {
          await this.runThreePhaseComparison();
          return;
        }

        // For regular chat (not implemented in this version)
        alert('Regular chat mode is not implemented. Please use the Compare Documents button.');
      },

      async runThreePhaseComparison() {
        this.state.isStreaming = true;
        this.updateSendButton(true);

        // Show output tabs immediately with streaming content (no loading spinner)
        document.getElementById('messages').style.display = 'none';
        document.getElementById('output-tabs').classList.add('active');
        this.showPhaseProgress(1, 'Reading document contents');

        try {
          // Get filename list once for all phases (ensures citations use actual filenames)
          const fileList = this.getUploadedFileList();

          // PHASE 1: Document Summary - tab switches when first chunk arrives
          this.state.currentPhase = 1;
          this.state.hasActivatedPhaseTab = false;
          this.state.currentResponse = '';
          this.state.currentThinking = '';

          const prompt1 = PROMPT_TEMPLATES.phase1(fileList);
          this.state.summaryResponse = await this.streamResponse(prompt1, true); // true = upload files

          // Phase 1 complete - show download button
          document.getElementById('download-summary-btn').style.display = 'inline-flex';

          // PHASE 2: Comparison Table - tab switches when first chunk arrives
          this.state.currentPhase = 2;
          this.state.hasActivatedPhaseTab = false;
          this.updatePhaseProgress(2, 'Comparing plan provisions');
          this.startProgressRotation(2);
          this.state.currentResponse = '';
          this.state.currentThinking = '';

          const prompt2 = PROMPT_TEMPLATES.phase2(this.state.summaryResponse, fileList);
          this.state.comparisonResponse = await this.streamResponse(prompt2, true); // true = upload files fresh

          // Phase 2 complete - show download button
          document.getElementById('download-comparison-btn').style.display = 'inline-flex';

          // PHASE 3: Language Comparison - tab switches when first chunk arrives
          this.state.currentPhase = 3;
          this.state.hasActivatedPhaseTab = false;
          this.updatePhaseProgress(3, 'Extracting exact language');
          this.startProgressRotation(3);
          this.state.currentResponse = '';
          this.state.currentThinking = '';

          const prompt3 = PROMPT_TEMPLATES.phase3(this.state.summaryResponse, this.state.comparisonResponse, fileList);
          this.state.languageResponse = await this.streamResponse(prompt3, true); // true = upload files fresh

          // Phase 3 complete - show download button
          document.getElementById('download-language-btn').style.display = 'inline-flex';

          // Complete - hide progress indicator and enable chat
          this.finalizeThreePhaseComparison();

        } catch (error) {
          this.handleError(error);
        } finally {
          this.state.isStreaming = false;
          this.state.currentPhase = 0;
          this.updateSendButton(false);
        }
      },

      createStreamingMessage() {
        const messagesContainer = document.getElementById('messages');

        // For comparison requests, skip creating loading indicator
        // We stream directly to tabs instead
        if (this.state.isComparisonRequest) {
          return;
        }

        // Regular chat: show normal streaming message
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message assistant streaming';
        messageDiv.id = 'streaming-message';
        messageDiv.innerHTML = `
          <div class="message-header">
            <span class="message-role">Assistant</span>
          </div>
          <div class="message-content">
            <div id="streaming-thinking" style="display: none;"></div>
            <div id="streaming-response"></div>
            <div class="streaming-indicator">
              <div class="dot"></div>
              <div class="dot"></div>
              <div class="dot"></div>
            </div>
          </div>
        `;
        messagesContainer.appendChild(messageDiv);
        this.scrollToBottom();
      },

      async streamResponse(userPrompt, uploadFiles = false) {
        this.state.abortController = new AbortController();

        // Build message parts
        const parts = [];

        // Add uploaded files if requested (fresh upload for each phase)
        if (uploadFiles) {
          const uploadedFiles = this.state.uploadedFiles.filter(f => f.status === 'uploaded');
          uploadedFiles.forEach(file => {
            parts.push({
              inline_data: {
                mime_type: file.mimeType,
                data: file.base64Data
              }
            });
          });
          console.log(`üì§ API Request: Uploading ${uploadedFiles.length} PDF file(s)`);
        }

        // Add user prompt text
        parts.push({ text: userPrompt });

        const contents = [{ role: 'user', parts }];

        const model = CONFIG.MODEL || 'gemini-3-pro-preview';

        // Build request body with vanilla system instruction
        const requestBody = {
          systemInstruction: {
            parts: [{ text: 'You are a helpful assistant.' }]
          },
          contents: contents,
          generationConfig: {
            maxOutputTokens: CONFIG.MAX_OUTPUT_TOKENS || 32768,
            temperature: 1.0,
            thinkingConfig: {
              thinkingLevel: CONFIG.THINKING_LEVEL || 'high'
            }
          }
        };

        console.log(`üì§ API Request: Phase ${this.state.currentPhase}/3 to ${model}`);
        console.log(`üìù Prompt (first 200 chars): ${userPrompt.substring(0, 200)}...`);

        const response = await fetch(
          this.getApiUrl(model),
          {
            method: 'POST',
            headers: this.getApiHeaders(),
            body: JSON.stringify(requestBody),
            signal: this.state.abortController.signal
          }
        );

        if (!response.ok) {
          const errorText = await response.text();
          console.error(`‚ùå API Error (${response.status}):`, errorText);
          throw new Error(`API request failed (${response.status}): ${errorText}`);
        }

        console.log(`‚úÖ API Response: Streaming started`);

        // Update status to reflect AI is now processing (for comparison requests)
        if (this.state.isComparisonRequest) {
          switch (this.state.currentPhase) {
            case 1: this.setPhaseStatus('Reading document structure...'); break;
            case 2: this.setPhaseStatus('Comparing procedures across plans...'); break;
            case 3: this.setPhaseStatus('Extracting language and citations...'); break;
          }
        }

        const reader = response.body
          .pipeThrough(new TextDecoderStream())
          .getReader();

        let buffer = '';
        let chunkCount = 0;

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += value;
          const events = buffer.split(/\r?\n\r?\n/);
          buffer = events.pop() || '';

          for (const event of events) {
            if (!event.trim()) continue;

            const lines = event.split(/\r?\n/);
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                try {
                  const jsonData = line.slice(6);
                  const chunk = JSON.parse(jsonData);
                  this.handleStreamChunk(chunk);
                  chunkCount++;
                } catch (e) {
                  console.error('Parse error:', e, line);
                }
              }
            }
          }
        }

        const responseLength = this.state.currentResponse.length;
        console.log(`‚úÖ API Response Complete: Phase ${this.state.currentPhase}/3 - ${chunkCount} chunks, ${responseLength} chars`);

        // Return the accumulated response
        return this.state.currentResponse;
      },

      handleStreamChunk(chunk) {
        // Extract parts from the chunk
        const candidate = chunk.candidates?.[0];
        if (!candidate || !candidate.content || !candidate.content.parts) return;

        for (const part of candidate.content.parts) {
          if (part.thought) {
            // This is a thinking summary
            // Thinking text might be in part.thought itself (if string) or part.text when part.thought is true
            const thinkingText = typeof part.thought === 'string' ? part.thought : (part.text || '');
            this.state.currentThinking += thinkingText;
            this.updateStreamingThinking();
          } else if (part.text) {
            // Activate tab on first text chunk (switch happens when content starts, not when request is sent)
            if (this.state.isComparisonRequest && !this.state.hasActivatedPhaseTab) {
              this.activatePhaseTab();
              this.state.hasActivatedPhaseTab = true;
            }

            // This is the main response
            this.state.currentResponse += part.text;
            this.updateStreamingResponse();
          }
        }

        // Check if thinking is done (finishReason indicates completion)
        if (candidate.finishReason && this.state.currentThinking && !this.state.thinkingCollapsed) {
          this.collapseStreamingThinking();
          this.state.thinkingCollapsed = true;
        }
      },

      updateStreamingThinking() {
        // Skip DOM updates for comparison requests (no streaming message to update)
        if (this.state.isComparisonRequest) return;

        const thinkingDiv = document.getElementById('streaming-thinking');
        if (thinkingDiv && this.state.currentThinking) {
          thinkingDiv.style.display = 'block';
          const thinkingId = 'thinking-streaming';
          thinkingDiv.innerHTML = `
            <div class="thinking-block">
              <div class="thinking-header" onclick="ChatApp.toggleThinking('${thinkingId}')">
                <span>Thinking</span>
                <span class="thinking-toggle" id="${thinkingId}-toggle">Hide</span>
              </div>
              <div class="thinking-content" id="${thinkingId}">
                ${this.escapeHtml(this.state.currentThinking)}
              </div>
            </div>
          `;
        }
      },

      collapseStreamingThinking() {
        const thinkingContent = document.getElementById('thinking-streaming');
        const thinkingToggle = document.getElementById('thinking-streaming-toggle');
        if (thinkingContent && thinkingToggle) {
          thinkingContent.classList.add('collapsed');
          thinkingToggle.textContent = 'Show';
        }
      },

      updateStreamingResponse() {
        let outputDiv;

        // For comparison requests, stream to the active phase's tab
        if (this.state.isComparisonRequest) {
          switch (this.state.currentPhase) {
            case 1: outputDiv = document.getElementById('summary-output'); break;
            case 2: outputDiv = document.getElementById('comparison-output'); break;
            case 3: outputDiv = document.getElementById('language-output'); break;
          }
        } else {
          outputDiv = document.getElementById('streaming-response');
        }

        if (outputDiv) {
          let html = marked.parse(this.state.currentResponse);
          // Apply citation highlighting for language/citations tab (phase 3)
          if (this.state.isComparisonRequest && this.state.currentPhase === 3) {
            html = this.highlightCitations(html);
          }
          outputDiv.innerHTML = html;
          this.scrollTabToBottom();
        }
      },

      scrollTabToBottom() {
        const activeTab = document.querySelector('.tab-content.active');
        if (activeTab) {
          activeTab.scrollTop = activeTab.scrollHeight;
        }
      },

      updateComparisonPhase(phase, phaseText) {
        // Legacy method - kept for compatibility
        // New streaming uses showPhaseProgress/updatePhaseProgress instead
        const phaseDiv = document.getElementById('comparison-phase');
        if (phaseDiv) {
          phaseDiv.textContent = `Phase ${phase}/3: ${phaseText}`;
        }

        // Update progress dots (old loading screen dots)
        for (let i = 1; i <= 3; i++) {
          const dot = document.getElementById(`progress-dot-${i}`);
          if (dot) {
            if (i <= phase) {
              dot.classList.add('active');
            } else {
              dot.classList.remove('active');
            }
          }
        }
      },

      // Phase Progress Indicator Methods (for tab bar)
      showPhaseProgress(phase, text) {
        const progress = document.getElementById('phase-progress');
        if (progress) {
          progress.classList.add('active');
          this.updatePhaseProgress(phase, text);
          // Start rotating contextual messages for this phase
          this.startProgressRotation(phase);
        }
      },

      updatePhaseProgress(phase, text) {
        const phaseText = document.getElementById('phase-text');
        if (phaseText) {
          phaseText.textContent = text;
        }

        // Update phase dots with complete/active states
        for (let i = 1; i <= 3; i++) {
          const dot = document.getElementById(`pdot-${i}`);
          if (dot) {
            dot.classList.remove('active', 'complete');
            if (i < phase) {
              dot.classList.add('complete');
            } else if (i === phase) {
              dot.classList.add('active');
            }
          }
        }
      },

      setPhaseStatus(text) {
        const phaseText = document.getElementById('phase-text');
        if (phaseText) {
          phaseText.textContent = text;
        }
      },

      hidePhaseProgress() {
        const progress = document.getElementById('phase-progress');
        if (progress) {
          progress.classList.remove('active');
        }
        this.stopProgressRotation();
      },

      // Start rotating progress messages for a phase
      startProgressRotation(phase) {
        const messages = PHASE_MESSAGES[phase];
        if (!messages) return;

        // Reset indices
        this.state.progressMessageIndex = 0;
        this.state.dotAnimationIndex = 0;

        // Clear any existing intervals/timeouts
        this.stopProgressRotation();

        // Set initial message
        this.updateProgressText(messages[0]);

        // Schedule next message rotation with randomized timing
        const scheduleNextMessage = () => {
          // Random delay between 5-8 seconds
          const delay = 5000 + Math.random() * 3000;
          this.state.progressMessageInterval = setTimeout(() => {
            this.state.progressMessageIndex = (this.state.progressMessageIndex + 1) % messages.length;
            this.updateProgressText(messages[this.state.progressMessageIndex]);
            scheduleNextMessage();
          }, delay);
        };
        scheduleNextMessage();

        // Animate dots every 500ms
        this.state.dotAnimationInterval = setInterval(() => {
          this.state.dotAnimationIndex = (this.state.dotAnimationIndex + 1) % 3;
          this.updateProgressDots();
        }, 500);
      },

      // Stop progress message rotation
      stopProgressRotation() {
        if (this.state.progressMessageInterval) {
          clearTimeout(this.state.progressMessageInterval);
          this.state.progressMessageInterval = null;
        }
        if (this.state.dotAnimationInterval) {
          clearInterval(this.state.dotAnimationInterval);
          this.state.dotAnimationInterval = null;
        }
      },

      // Update the progress text (separate from dots)
      updateProgressText(text) {
        const phaseText = document.getElementById('phase-text');
        if (phaseText) {
          phaseText.textContent = text;
        }
      },

      // Update just the dots animation (in separate element)
      updateProgressDots() {
        const dotsEl = document.getElementById('phase-dots-anim');
        if (dotsEl) {
          const dots = '.'.repeat(this.state.dotAnimationIndex + 1);
          dotsEl.textContent = dots;
        }
      },

      activatePhaseTab() {
        // Map current phase number to tab name
        switch (this.state.currentPhase) {
          case 1: this.activateTab('summary'); break;
          case 2: this.activateTab('comparison'); break;
          case 3: this.activateTab('language'); break;
        }
      },

      finalizeThreePhaseComparison() {
        // Hide the phase progress indicator
        this.hidePhaseProgress();

        // Show split view (chat sidebar)
        const splitView = document.getElementById('split-view');
        const outputTabs = document.getElementById('output-tabs');
        splitView.classList.add('active');

        // Set chat panel to collapsed state by default
        const chatPanel = document.getElementById('chat-panel');
        const collapseButton = document.getElementById('collapse-chat-button');
        if (chatPanel && this.state.chatPanelCollapsed) {
          chatPanel.classList.add('collapsed');
          splitView.style.width = '48px';
          if (outputTabs) {
            outputTabs.style.marginRight = '52px';
          }
          if (collapseButton) {
            collapseButton.innerHTML = '‚óÄ';
            collapseButton.title = 'Expand chat panel';
          }
        } else if (chatPanel) {
          // Expanded state
          splitView.classList.add('expanded');
          this.updateChatPanelWidth();
          if (collapseButton) {
            collapseButton.innerHTML = '‚ñ∂';
            collapseButton.title = 'Collapse chat panel';
          }
        }

        // Initialize resize handle (only once)
        if (!this._resizeHandleInitialized) {
          this.initResizeHandle();
          this._resizeHandleInitialized = true;
        }

        // Initialize chat event listeners
        this.initChatEventListeners();

        // Render initial result panel content (for when chat expands)
        this.renderMiniResultPanel(this.state.chatPanelResultTab);

        // Reset state
        this.state.isComparisonRequest = false;

        // Save analysis to database (async, non-blocking)
        this.saveAnalysis();
      },

      renderSummaryTab() {
        const output = document.getElementById('summary-output');
        // Render the summary response as markdown
        output.innerHTML = marked.parse(this.state.summaryResponse || '');
        // Apply note highlights after rendering
        this.applyNoteHighlights('summary');
      },

      renderComparisonTab() {
        const output = document.getElementById('comparison-output');
        // Parse the comparison response and render as HTML table
        // The response should be a markdown table, so we can render it directly
        output.innerHTML = marked.parse(this.state.comparisonResponse || '');
        // Apply note highlights after rendering
        this.applyNoteHighlights('comparison');
      },

      // Find uploaded file by citation filename (exact, case-insensitive, or fuzzy match)
      // Includes files with r2Key (can open via R2 URL) or uploaded status (has base64)
      findUploadedFile(citedFilename) {
        const files = this.state.uploadedFiles.filter(f => f.status === 'uploaded' || f.r2Key);

        // 1. Exact match
        let match = files.find(f => f.filename === citedFilename);
        if (match) return { file: match, confidence: 'exact' };

        // 2. Case-insensitive exact match
        match = files.find(f => f.filename.toLowerCase() === citedFilename.toLowerCase());
        if (match) return { file: match, confidence: 'case-insensitive' };

        // 3. Fuzzy match: check if cited name is contained in uploaded filename or vice versa
        const citedBase = citedFilename.replace(/\.pdf$/i, '').toLowerCase();
        match = files.find(f => {
          const uploadedBase = f.filename.replace(/\.pdf$/i, '').toLowerCase();
          return uploadedBase.includes(citedBase) || citedBase.includes(uploadedBase);
        });
        if (match) return { file: match, confidence: 'fuzzy' };

        // 4. No match found
        return { file: null, confidence: 'none' };
      },

      // Get or create blob URL for a file (cached for efficiency)
      getBlobUrlForFile(file) {
        if (this.state.blobUrlCache[file.filename]) {
          return this.state.blobUrlCache[file.filename];
        }

        const byteCharacters = atob(file.base64Data);
        const byteArray = new Uint8Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
          byteArray[i] = byteCharacters.charCodeAt(i);
        }
        const blob = new Blob([byteArray], { type: 'application/pdf' });
        const blobUrl = URL.createObjectURL(blob);

        this.state.blobUrlCache[file.filename] = blobUrl;
        return blobUrl;
      },

      // Open PDF at specific page in new tab
      // Prefers R2 URLs (work even before base64 loaded) over blob URLs
      openPdfAtPage(filename, pageNumber) {
        const result = this.findUploadedFile(filename);

        if (!result.file) {
          console.warn(`Could not find uploaded file matching: ${filename}`);
          return false;
        }

        const file = result.file;

        // Prefer R2 URL if available (works even if base64 not loaded yet)
        if (file.r2Key) {
          window.open(`/api/files/${file.r2Key}#page=${pageNumber}`, '_blank');
          return true;
        }

        // Fall back to blob URL if we have base64 data
        if (file.base64Data) {
          const blobUrl = this.getBlobUrlForFile(file);
          window.open(`${blobUrl}#page=${pageNumber}`, '_blank');
          return true;
        }

        console.warn(`File ${filename} has no R2 key or base64 data`);
        return false;
      },

      // Highlight citation patterns and make them clickable
      highlightCitations(html) {
        // Pattern captures: (filename.pdf, page N, optional paragraph info)
        // Handles variations: pg, pg., page, paragraph, para, para.
        // Uses .+? (non-greedy) to allow parentheses within filenames like "(SPD)" or "(eff. 06.01.05)"
        const citationPattern = /\((?:["']|&quot;)?(.+?\.pdf)(?:["']|&quot;)?\s*,\s*(?:pg\.?\s*|page\s*)?(\d+)\s*(?:,\s*(?:para(?:graph)?\.?\s*)?([^)]*))?\)/gi;

        return html.replace(citationPattern, (match, filename, page, paragraph) => {
          const result = this.findUploadedFile(filename);
          const pageNum = parseInt(page, 10);

          // Citation is clickable if file has r2Key (R2 storage) or base64Data (local)
          const file = result.file;
          const isClickable = file && (file.r2Key || file.base64Data);

          if (isClickable) {
            // Clickable citation - opens PDF at page
            const escapedFilename = this.escapeHtml(filename).replace(/'/g, "\\'");
            const title = result.confidence === 'fuzzy'
              ? `Opens: ${this.escapeHtml(file.filename)} (fuzzy match)`
              : `Opens: ${this.escapeHtml(file.filename)}`;

            return `<a href="#" class="citation citation-link" onclick="ChatApp.openPdfAtPage('${escapedFilename}', ${pageNum}); return false;" title="${title}">(${this.escapeHtml(filename)}, page ${page}${paragraph ? ', ' + this.escapeHtml(paragraph) : ''})</a>`;
          } else if (file) {
            // File found but not yet loaded - show as pending
            return `<span class="citation citation-pending" title="Loading file...">(${this.escapeHtml(filename)}, page ${page}${paragraph ? ', ' + this.escapeHtml(paragraph) : ''})</span>`;
          } else {
            // Non-clickable - file not found
            return `<span class="citation citation-unmatched" title="File not found in uploads">(${this.escapeHtml(filename)}, page ${page}${paragraph ? ', ' + this.escapeHtml(paragraph) : ''})</span>`;
          }
        });
      },

      renderLanguageTab() {
        const output = document.getElementById('language-output');
        // Parse the language comparison response and render as HTML table
        // The response should be a markdown table, so we can render it directly
        const html = marked.parse(this.state.languageResponse || '');
        output.innerHTML = this.highlightCitations(html);
        // Apply note highlights after rendering
        this.applyNoteHighlights('language');
      },

      activateTab(tabName) {
        // Update active tab in state
        this.state.activeTab = tabName;

        // Update tab button classes
        document.querySelectorAll('.tab-button').forEach(btn => {
          btn.classList.remove('active');
        });
        const activeButton = document.querySelector(`.tab-button[data-tab="${tabName}"]`);
        if (activeButton) {
          activeButton.classList.add('active');
        }

        // Show/hide tab content
        document.querySelectorAll('.tab-content').forEach(tab => {
          tab.classList.remove('active');
        });
        const activeTab = document.getElementById(`tab-${tabName}`);
        if (activeTab) {
          activeTab.classList.add('active');
        }
      },

      finalizeStreamingMessage() {
        // Remove loading indicator for comparison requests
        const comparisonLoading = document.getElementById('comparison-loading');
        if (comparisonLoading) {
          comparisonLoading.remove();
        }

        // Remove regular streaming message for chat
        const streamingMessage = document.getElementById('streaming-message');
        if (streamingMessage) {
          streamingMessage.remove();
        }

        // Try to parse as JSON and render outputs
        try {
          this.parseAndRenderOutputs(this.state.currentResponse);
        } catch (error) {
          // If JSON parsing fails, fall back to regular message display
          console.error('Not JSON response, falling back to message display:', error);
          this.addMessage('model', this.state.currentResponse, this.state.currentThinking);
          this.render();
        }

        // Reset streaming state
        this.state.currentThinking = '';
        this.state.currentResponse = '';
        this.state.thinkingCollapsed = false;
        this.state.isComparisonRequest = false; // Reset comparison flag
      },

      toggleThinking(id) {
        const content = document.getElementById(id);
        const toggle = document.getElementById(id + '-toggle');
        if (content && toggle) {
          content.classList.toggle('collapsed');
          toggle.textContent = content.classList.contains('collapsed') ? 'Show' : 'Hide';
        }
      },

      render() {
        const messagesContainer = document.getElementById('messages');
        const streamingMessage = document.getElementById('streaming-message');

        // Don't re-render if streaming
        if (streamingMessage) return;

        // Clear and rebuild (except streaming message)
        const messages = this.state.messages.map((msg, index) => {
          const thinking = msg.thinking || '';
          const thinkingId = `thinking-${index}`;

          if (msg.role === 'user') {
            return `
              <div class="message user">
                <div class="message-header">
                  <span class="message-role">You</span>
                </div>
                <div class="message-content">
                  ${this.escapeHtml(msg.content)}
                </div>
              </div>
            `;
          } else {
            return `
              <div class="message assistant">
                <div class="message-header">
                  <span class="message-role">Assistant</span>
                </div>
                <div class="message-content">
                  ${thinking ? `
                    <div class="thinking-block">
                      <div class="thinking-header" onclick="ChatApp.toggleThinking('${thinkingId}')">
                        <span>Thinking</span>
                        <span class="thinking-toggle" id="${thinkingId}-toggle">Show</span>
                      </div>
                      <div class="thinking-content collapsed" id="${thinkingId}">
                        ${this.escapeHtml(thinking)}
                      </div>
                    </div>
                  ` : ''}
                  <div class="response-text">
                    ${marked.parse(msg.content)}
                  </div>
                </div>
              </div>
            `;
          }
        }).join('');

        messagesContainer.innerHTML = messages;
        this.scrollToBottom();
      },

      handleError(error) {
        console.error('Chat error:', error);

        // Hide phase progress indicator if visible
        this.hidePhaseProgress();

        const streamingMessage = document.getElementById('streaming-message');
        if (streamingMessage) {
          streamingMessage.remove();
        }

        // If this was a comparison request that failed, reset UI
        if (this.state.isComparisonRequest) {
          document.getElementById('output-tabs').classList.remove('active');
          document.getElementById('messages').style.display = 'block';
          this.state.messages = [];
          this.renderInputArea();
        }
        // If this was the first message and it failed, revert to initial state
        else if (this.state.messages.length === 1 && this.state.messages[0].role === 'user') {
          this.state.messages = []; // Clear the failed attempt
          this.renderInputArea(); // Show Compare button again
        }

        const messagesContainer = document.getElementById('messages');
        const errorDiv = document.createElement('div');
        errorDiv.className = 'message assistant';
        errorDiv.innerHTML = `
          <div class="message-header">
            <span class="message-role">Error</span>
          </div>
          <div class="message-content">
            <div class="error-message">
              <strong>Error:</strong> ${this.escapeHtml(error.message)}
              ${this.state.messages.length === 0 ? '<br><small>Try clicking "Compare Documents" again.</small>' : ''}
            </div>
          </div>
        `;
        messagesContainer.appendChild(errorDiv);
        this.scrollToBottom();
      },

      updateSendButton(disabled) {
        const button = document.getElementById('send-button');
        if (button) {
          button.disabled = disabled;
          button.textContent = disabled ? 'Sending...' : 'Send';
        }
      },

      scrollToBottom() {
        const container = document.getElementById('messages');
        container.scrollTop = container.scrollHeight;
      },

      escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      },

      // File Upload Functions
      initFileUpload() {
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');

        // Click to browse
        dropZone.addEventListener('click', () => {
          fileInput.click();
        });

        // File selection
        fileInput.addEventListener('change', (e) => {
          this.handleFileSelect(e.target.files);
          fileInput.value = ''; // Reset input
        });

        // Drag and drop
        dropZone.addEventListener('dragover', (e) => this.handleDragOver(e));
        dropZone.addEventListener('dragleave', (e) => this.handleDragLeave(e));
        dropZone.addEventListener('drop', (e) => this.handleDrop(e));
      },

      toggleFilesPanel() {
        this.state.filesPanelExpanded = !this.state.filesPanelExpanded;
        const content = document.getElementById('files-content');
        const toggle = document.getElementById('files-toggle');

        if (this.state.filesPanelExpanded) {
          content.classList.remove('collapsed');
          toggle.classList.remove('collapsed');
          toggle.textContent = '‚ñº';
        } else {
          content.classList.add('collapsed');
          toggle.classList.add('collapsed');
          toggle.textContent = '‚ñ∂';
        }
      },

      handleFileSelect(files) {
        if (files.length === 0) return;

        Array.from(files).forEach(file => {
          this.uploadFile(file);
        });
      },

      handleDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        const dropZone = document.getElementById('drop-zone');
        dropZone.classList.add('dragging');
      },

      handleDragLeave(e) {
        e.preventDefault();
        e.stopPropagation();
        const dropZone = document.getElementById('drop-zone');
        if (e.target === dropZone) {
          dropZone.classList.remove('dragging');
        }
      },

      handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        const dropZone = document.getElementById('drop-zone');
        dropZone.classList.remove('dragging');

        const files = e.dataTransfer.files;
        this.handleFileSelect(files);
      },

      async uploadFile(file) {
        // Validate file size (20 MB limit for inline base64)
        const maxSize = 20 * 1024 * 1024; // 20 MB in bytes
        if (file.size > maxSize) {
          alert(`File "${file.name}" is too large. Maximum size is 20 MB per file for inline upload.`);
          return;
        }

        // Create temporary file card
        const tempId = 'file-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        const fileObj = {
          id: tempId,
          filename: file.name,
          size: file.size,
          mimeType: file.type || 'application/pdf',
          status: 'uploading',
          uploadedAt: new Date().toISOString(),
          base64Data: null
        };

        this.state.uploadedFiles.push(fileObj);
        this.renderFilesList();
        this.updateFilesCount();

        try {
          // Read file as base64
          const base64Data = await this.readFileAsBase64(file);

          // Update file object with base64 data
          const fileIndex = this.state.uploadedFiles.findIndex(f => f.id === tempId);
          if (fileIndex !== -1) {
            this.state.uploadedFiles[fileIndex].base64Data = base64Data;
            this.state.uploadedFiles[fileIndex].status = 'uploaded';
          }

          this.renderFilesList();
          this.renderInputArea(); // Update button state

        } catch (error) {
          console.error('Upload error:', error);

          // Mark file as error
          const fileIndex = this.state.uploadedFiles.findIndex(f => f.id === tempId);
          if (fileIndex !== -1) {
            this.state.uploadedFiles[fileIndex].status = 'error';
            this.state.uploadedFiles[fileIndex].error = error.message;
          }

          this.renderFilesList();
          this.renderInputArea(); // Update button state
          alert(`Failed to load "${file.name}": ${error.message}`);
        }
      },

      readFileAsBase64(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();

          reader.onload = () => {
            // Remove the data URL prefix (e.g., "data:application/pdf;base64,")
            const base64String = reader.result.split(',')[1];
            resolve(base64String);
          };

          reader.onerror = () => {
            reject(new Error('Failed to read file'));
          };

          reader.readAsDataURL(file);
        });
      },

      removeFile(fileId) {
        // Clean up blob URL if cached
        const file = this.state.uploadedFiles.find(f => f.id === fileId);
        if (file && this.state.blobUrlCache[file.filename]) {
          URL.revokeObjectURL(this.state.blobUrlCache[file.filename]);
          delete this.state.blobUrlCache[file.filename];
        }
        // Remove from state (base64 data is stored locally, no API cleanup needed)
        this.state.uploadedFiles = this.state.uploadedFiles.filter(f => f.id !== fileId);
        this.renderFilesList();
        this.updateFilesCount();
        this.renderInputArea(); // Update button state
      },

      renderFilesList() {
        const filesList = document.getElementById('files-list');

        if (this.state.uploadedFiles.length === 0) {
          filesList.innerHTML = '';
          return;
        }

        filesList.innerHTML = this.state.uploadedFiles.map(file => {
          const icon = this.getFileIcon(file.mimeType);
          const statusClass = file.status;
          const statusText = file.status === 'uploading' ? '‚è≥ Uploading...' :
                            file.status === 'loading' ? '‚è≥ Loading...' :
                            file.status === 'uploaded' ? '‚úì Ready' :
                            file.status === 'metadata_only' ? 'üìã Metadata only' :
                            file.status === 'error' ? `‚úó ${file.error || 'Error'}` :
                            '‚úó Error';

          return `
            <div class="file-card ${statusClass}">
              <div class="file-icon">${icon}</div>
              <div class="file-info">
                <div class="file-name">${this.escapeHtml(file.filename)}</div>
                <div class="file-meta">
                  <span class="file-size">${this.formatFileSize(file.size)}</span>
                  <span class="file-status ${statusClass}">${statusText}</span>
                </div>
              </div>
              <button class="file-remove" onclick="ChatApp.removeFile('${file.id}')" title="Remove file">
                √ó
              </button>
            </div>
          `;
        }).join('');
      },

      updateFilesCount() {
        const count = this.state.uploadedFiles.length;
        const filesCount = document.getElementById('files-count');
        filesCount.textContent = `(${count} ${count === 1 ? 'file' : 'files'})`;
      },

      formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return Math.round(bytes / Math.pow(k, i) * 10) / 10 + ' ' + sizes[i];
      },

      getFileIcon(mimeType) {
        const pdfIcon = `<svg viewBox="0 0 24 24" width="28" height="28" fill="none" stroke="#c0392b" stroke-width="1.5">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" fill="#fdf2f2"/>
          <polyline points="14 2 14 8 20 8" stroke="#c0392b"/>
          <text x="12" y="16" font-size="6" font-weight="bold" fill="#c0392b" text-anchor="middle" font-family="system-ui">PDF</text>
        </svg>`;

        const imageIcon = `<svg viewBox="0 0 24 24" width="28" height="28" fill="none" stroke="#1e3a5f" stroke-width="1.5">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2" fill="#f0f4f8"/>
          <circle cx="8.5" cy="8.5" r="1.5" fill="#1e3a5f"/>
          <polyline points="21 15 16 10 5 21" stroke="#1e3a5f"/>
        </svg>`;

        const wordIcon = `<svg viewBox="0 0 24 24" width="28" height="28" fill="none" stroke="#2980b9" stroke-width="1.5">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" fill="#ebf5fb"/>
          <polyline points="14 2 14 8 20 8" stroke="#2980b9"/>
          <line x1="8" y1="13" x2="16" y2="13" stroke="#2980b9"/>
          <line x1="8" y1="17" x2="14" y2="17" stroke="#2980b9"/>
        </svg>`;

        const spreadsheetIcon = `<svg viewBox="0 0 24 24" width="28" height="28" fill="none" stroke="#27ae60" stroke-width="1.5">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" fill="#eafaf1"/>
          <polyline points="14 2 14 8 20 8" stroke="#27ae60"/>
          <line x1="8" y1="12" x2="8" y2="18" stroke="#27ae60"/>
          <line x1="12" y1="12" x2="12" y2="18" stroke="#27ae60"/>
          <line x1="6" y1="14" x2="18" y2="14" stroke="#27ae60"/>
          <line x1="6" y1="16" x2="18" y2="16" stroke="#27ae60"/>
        </svg>`;

        const textIcon = `<svg viewBox="0 0 24 24" width="28" height="28" fill="none" stroke="#7f8c8d" stroke-width="1.5">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" fill="#f8f9fa"/>
          <polyline points="14 2 14 8 20 8" stroke="#7f8c8d"/>
          <line x1="8" y1="13" x2="16" y2="13" stroke="#7f8c8d"/>
          <line x1="8" y1="17" x2="12" y2="17" stroke="#7f8c8d"/>
        </svg>`;

        const defaultIcon = `<svg viewBox="0 0 24 24" width="28" height="28" fill="none" stroke="#1e3a5f" stroke-width="1.5">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" fill="#f7f9fc"/>
          <polyline points="14 2 14 8 20 8" stroke="#1e3a5f"/>
        </svg>`;

        if (!mimeType) return defaultIcon;

        if (mimeType.includes('pdf')) return pdfIcon;
        if (mimeType.includes('image')) return imageIcon;
        if (mimeType.includes('word') || mimeType.includes('document')) return wordIcon;
        if (mimeType.includes('spreadsheet') || mimeType.includes('excel') || mimeType.includes('csv')) return spreadsheetIcon;
        if (mimeType.includes('text')) return textIcon;

        return defaultIcon;
      },

      // ===== NEW: Three-Output Tab System =====

      switchTab(tabName) {
        // Update active tab state
        this.state.activeTab = tabName;

        // Update tab buttons
        document.querySelectorAll('.tab-button').forEach(btn => {
          btn.classList.remove('active');
        });
        event.target.classList.add('active');

        // Update tab content (summary/comparison/language)
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(`tab-${tabName}`).classList.add('active');

        // Also update mini result panel to match (for chat sidebar)
        this.renderMiniResultPanel(tabName);
      },

      // ===== Chat Feature Methods =====

      switchMiniResultTab(resultType) {
        // Update state
        this.state.chatPanelResultTab = resultType;

        // Update mini-tab styling
        document.querySelectorAll('.mini-tab').forEach(tab => {
          tab.classList.toggle('active', tab.dataset.result === resultType);
        });

        // Render selected result in left panel
        this.renderMiniResultPanel(resultType);
      },

      renderMiniResultPanel(resultType) {
        const content = document.getElementById('mini-output-content');
        let markdown = '';

        switch(resultType) {
          case 'summary':
            markdown = this.state.summaryResponse;
            break;
          case 'comparison':
            markdown = this.state.comparisonResponse;
            break;
          case 'language':
            markdown = this.state.languageResponse;
            break;
        }

        let html = marked.parse(markdown || '');
        // Apply citation highlighting for language/citations panel
        if (resultType === 'language') {
          html = this.highlightCitations(html);
        }
        content.innerHTML = html;
      },

      initResizeHandle() {
        const handle = document.getElementById('resize-handle');
        const splitView = document.getElementById('split-view');
        const collapseButton = document.getElementById('collapse-chat-button');

        if (!handle || !splitView) return;

        // Handle drag to resize
        handle.addEventListener('mousedown', (e) => {
          // Don't start resize if clicking the collapse button
          if (e.target === collapseButton || e.target.closest('.collapse-button')) {
            return;
          }

          this.state.isResizing = true;
          document.body.classList.add('resizing');
          e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
          if (!this.state.isResizing) return;

          // Calculate width from the right edge of viewport
          const viewportWidth = window.innerWidth;
          const newWidth = viewportWidth - e.clientX;

          // Constrain between 300px and 800px
          const constrainedWidth = Math.min(Math.max(newWidth, 300), 800);
          this.state.chatPanelWidth = constrainedWidth;

          this.updateChatPanelWidth();
        });

        document.addEventListener('mouseup', () => {
          if (this.state.isResizing) {
            this.state.isResizing = false;
            document.body.classList.remove('resizing');
            // Persist to localStorage
            localStorage.setItem('chatPanelWidth', this.state.chatPanelWidth);
          }
        });

        // Handle collapse button
        if (collapseButton) {
          collapseButton.addEventListener('click', () => this.toggleChatPanel());
        }
      },

      updateChatPanelWidth() {
        const splitView = document.getElementById('split-view');
        const outputTabs = document.getElementById('output-tabs');

        if (splitView && !this.state.chatPanelCollapsed) {
          splitView.style.width = `${this.state.chatPanelWidth}px`;
          if (outputTabs) {
            outputTabs.style.marginRight = `${this.state.chatPanelWidth + 4}px`;
          }
        }
      },

      toggleChatPanel() {
        this.state.chatPanelCollapsed = !this.state.chatPanelCollapsed;
        const splitView = document.getElementById('split-view');
        const chatPanel = document.getElementById('chat-panel');
        const collapseButton = document.getElementById('collapse-chat-button');
        const outputTabs = document.getElementById('output-tabs');

        if (this.state.chatPanelCollapsed) {
          // Collapse to 48px sidebar
          splitView.classList.remove('expanded');
          splitView.style.width = '48px';
          chatPanel.classList.add('collapsed');
          if (outputTabs) {
            outputTabs.style.marginRight = '52px';
          }
          if (collapseButton) {
            collapseButton.innerHTML = '‚óÄ';
            collapseButton.title = 'Expand chat panel';
          }
        } else {
          // Expand chat panel
          splitView.classList.add('expanded');
          chatPanel.classList.remove('collapsed');
          // Apply saved width
          this.updateChatPanelWidth();
          if (collapseButton) {
            collapseButton.innerHTML = '‚ñ∂';
            collapseButton.title = 'Collapse chat panel';
          }
        }

        // Persist to localStorage
        localStorage.setItem('chatPanelCollapsed', this.state.chatPanelCollapsed);
      },

      initChatEventListeners() {
        const chatInput = document.getElementById('chat-input');
        const chatSendButton = document.getElementById('chat-send-button');

        // Remove existing listeners to avoid duplicates
        const newChatInput = chatInput.cloneNode(true);
        const newChatSendButton = chatSendButton.cloneNode(true);
        chatInput.parentNode.replaceChild(newChatInput, chatInput);
        chatSendButton.parentNode.replaceChild(newChatSendButton, chatSendButton);

        // Add new listeners
        newChatSendButton.addEventListener('click', () => {
          const message = newChatInput.value.trim();
          if (message && !this.state.isChatStreaming) {
            this.sendChatMessage(message);
            newChatInput.value = '';
            newChatInput.style.height = 'auto';
          }
        });

        newChatInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            newChatSendButton.click();
          }
        });

        newChatInput.addEventListener('input', () => {
          newChatInput.style.height = 'auto';
          newChatInput.style.height = Math.min(newChatInput.scrollHeight, 150) + 'px';
        });
      },

      async sendChatMessage(userQuestion) {
        // Add user message to chat history
        this.state.chatMessages.push({
          role: 'user',
          content: userQuestion,
          timestamp: new Date().toISOString()
        });

        this.renderChatMessages();

        // Build context-enriched prompt
        const contextPrompt = this.buildChatContextPrompt(userQuestion);

        // Stream response with PDFs re-uploaded
        this.state.isChatStreaming = true;
        this.state.currentChatResponse = '';

        // Show streaming indicator
        this.showChatStreamingIndicator();

        const chatSendButton = document.getElementById('chat-send-button');
        if (chatSendButton) {
          chatSendButton.disabled = true;
          chatSendButton.textContent = 'Sending...';
        }

        try {
          const response = await this.streamChatResponse(contextPrompt, true);

          // Add assistant response to history
          this.state.chatMessages.push({
            role: 'assistant',
            content: response,
            timestamp: new Date().toISOString()
          });

          this.renderChatMessages();

          // Save chat messages to database (async, non-blocking)
          this.saveChatMessages();
        } catch (error) {
          console.error('Chat error:', error);
          this.state.chatMessages.push({
            role: 'assistant',
            content: `Error: ${error.message}`,
            timestamp: new Date().toISOString()
          });
          this.renderChatMessages();
        } finally {
          this.state.isChatStreaming = false;
          this.state.currentChatResponse = '';

          if (chatSendButton) {
            chatSendButton.disabled = false;
            chatSendButton.textContent = 'Send';
          }
        }
      },

      buildChatContextPrompt(userQuestion) {
        const fileList = this.getUploadedFileList();
        return `You are analyzing pension plan documents. Here is the completed analysis:

<document_summary>
${this.state.summaryResponse}
</document_summary>

<comparison_table>
${this.state.comparisonResponse}
</comparison_table>

<detailed_language_comparison>
${this.state.languageResponse}
</detailed_language_comparison>

<uploaded_documents>
${fileList}
</uploaded_documents>

When referencing documents, use the EXACT filenames listed above. When citing, use the format: (filename, page_number, paragraph_number). When referencing the comparison table, cite specific rows or elements.

User Question: ${userQuestion}`;
      },

      async streamChatResponse(prompt, uploadFiles) {
        this.state.abortController = new AbortController();

        // Build message parts
        const parts = [];

        // Re-upload PDFs
        if (uploadFiles) {
          const uploadedFiles = this.state.uploadedFiles.filter(f => f.status === 'uploaded');
          uploadedFiles.forEach(file => {
            parts.push({
              inline_data: {
                mime_type: file.mimeType,
                data: file.base64Data
              }
            });
          });
          console.log(`üì§ Chat API Request: Uploading ${uploadedFiles.length} PDF file(s)`);
        }

        parts.push({ text: prompt });

        const contents = [{ role: 'user', parts }];

        const model = CONFIG.MODEL || 'gemini-3-pro-preview';

        const requestBody = {
          systemInstruction: {
            parts: [{ text: 'You are a helpful assistant.' }]
          },
          contents: contents,
          generationConfig: {
            maxOutputTokens: CONFIG.MAX_OUTPUT_TOKENS || 32768,
            temperature: 1.0,
            thinkingConfig: {
              thinkingLevel: CONFIG.THINKING_LEVEL || 'high'
            }
          }
        };

        console.log(`üì§ Chat API Request to ${model}`);

        const response = await fetch(
          this.getApiUrl(model),
          {
            method: 'POST',
            headers: this.getApiHeaders(),
            body: JSON.stringify(requestBody),
            signal: this.state.abortController.signal
          }
        );

        if (!response.ok) {
          const errorText = await response.text();
          console.error(`‚ùå Chat API Error (${response.status}):`, errorText);
          throw new Error(`API request failed (${response.status}): ${errorText}`);
        }

        console.log(`‚úÖ Chat API Response: Streaming started`);

        const reader = response.body
          .pipeThrough(new TextDecoderStream())
          .getReader();

        let buffer = '';
        let chunkCount = 0;

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += value;
          const events = buffer.split(/\r?\n\r?\n/);
          buffer = events.pop() || '';

          for (const event of events) {
            if (!event.trim()) continue;

            const lines = event.split(/\r?\n/);
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                try {
                  const jsonData = line.slice(6);
                  const chunk = JSON.parse(jsonData);
                  this.handleChatStreamChunk(chunk);
                  chunkCount++;
                } catch (e) {
                  console.error('Parse error:', e, line);
                }
              }
            }
          }
        }

        console.log(`‚úÖ Chat API Response Complete: ${chunkCount} chunks, ${this.state.currentChatResponse.length} chars`);

        return this.state.currentChatResponse;
      },

      handleChatStreamChunk(chunk) {
        const candidate = chunk.candidates?.[0];
        if (!candidate || !candidate.content || !candidate.content.parts) return;

        for (const part of candidate.content.parts) {
          if (part.text) {
            // Handle response text
            this.state.currentChatResponse += part.text;
            this.updateChatStreamingMessage();
          }
        }
      },

      showChatStreamingIndicator() {
        const chatMessages = document.getElementById('chat-messages');
        const streamingDiv = document.createElement('div');
        streamingDiv.id = 'chat-streaming-message';
        streamingDiv.className = 'chat-message assistant';
        streamingDiv.innerHTML = `
          <div class="chat-message-header">Assistant</div>
          <div class="chat-message-content">
            <div id="chat-streaming-response"></div>
            <div class="chat-streaming-indicator">
              <div class="dot"></div>
              <div class="dot"></div>
              <div class="dot"></div>
            </div>
          </div>
        `;
        chatMessages.appendChild(streamingDiv);
        this.scrollChatToBottom();
      },

      updateChatStreamingMessage() {
        const responseDiv = document.getElementById('chat-streaming-response');
        if (responseDiv) {
          responseDiv.innerHTML = marked.parse(this.state.currentChatResponse);
          this.scrollChatToBottom();
        }
      },

      renderChatMessages() {
        const chatMessages = document.getElementById('chat-messages');

        // Remove streaming message if exists
        const streamingMsg = document.getElementById('chat-streaming-message');
        if (streamingMsg) {
          streamingMsg.remove();
        }

        // Render all messages
        chatMessages.innerHTML = this.state.chatMessages.map((msg, index) => {
          const roleClass = msg.role === 'user' ? 'user' : 'assistant';
          const header = msg.role === 'user' ? 'You' : 'Assistant';

          return `
            <div class="chat-message ${roleClass}">
              <div class="chat-message-header">${header}</div>
              <div class="chat-message-content">
                ${msg.role === 'assistant' ? marked.parse(msg.content) : this.escapeHtml(msg.content)}
              </div>
            </div>
          `;
        }).join('');

        this.scrollChatToBottom();
      },

      scrollChatToBottom() {
        const container = document.getElementById('chat-messages');
        if (container) {
          container.scrollTop = container.scrollHeight;
        }
      },

      // ===== End Chat Feature Methods =====

      parseAndRenderOutputs(jsonResponse) {
        try {
          // Clean and extract JSON from response
          let cleanJson = jsonResponse.trim();

          // Remove markdown code fences if present
          if (cleanJson.startsWith('```json')) {
            cleanJson = cleanJson.replace(/^```json\s*/i, '').replace(/\s*```\s*$/, '');
          } else if (cleanJson.startsWith('```')) {
            cleanJson = cleanJson.replace(/^```\s*/, '').replace(/\s*```\s*$/, '');
          }

          // Try to extract JSON object if there's extra text
          const jsonMatch = cleanJson.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            cleanJson = jsonMatch[0];
          }

          console.log('Attempting to parse JSON:', cleanJson.substring(0, 200) + '...');

          // Parse JSON response
          const data = JSON.parse(cleanJson);
          this.state.comparisonData = data;

          // Hide messages container, show output tabs
          document.getElementById('messages').style.display = 'none';
          document.getElementById('output-tabs').classList.add('active');

          // Render each output
          this.renderSummary(data.summary);
          this.renderComparisonSpreadsheet(data.comparison_spreadsheet, data.plan_units);
          this.renderLanguageComparison(data.language_comparison, data.plan_units);

        } catch (error) {
          console.error('Failed to parse JSON response:', error);
          console.error('Raw response:', jsonResponse.substring(0, 500));
          this.handleError(new Error('Failed to parse comparison results. Please try again.'));
        }
      },

      renderSummary(summaryData) {
        const output = document.getElementById('summary-output');

        let markdown = '## Document Inventory\n\n';
        summaryData.document_inventory.forEach(unit => {
          markdown += `### ${unit.plan_unit}\n`;
          unit.documents.forEach(doc => {
            markdown += `- **${doc.type}** (Effective: ${doc.effective_date}) - ${doc.filename}\n`;
          });
          markdown += '\n';
        });

        markdown += '## Key Findings\n\n';
        summaryData.key_findings.forEach(finding => {
          markdown += `- ${finding}\n`;
        });

        markdown += '\n## Completeness Assessment\n\n';
        markdown += summaryData.completeness_assessment + '\n\n';

        markdown += '## Recommendations\n\n';
        summaryData.recommendations.forEach(rec => {
          markdown += `- ${rec}\n`;
        });

        output.innerHTML = marked.parse(markdown);
      },

      renderComparisonSpreadsheet(spreadsheetData, planUnits) {
        const output = document.getElementById('comparison-output');

        let html = '<table class="comparison-table"><thead><tr>';

        // Headers: Procedure Element + all plan units
        html += '<th>Procedure Element</th>';
        planUnits.forEach(planName => {
          html += `<th>${this.escapeHtml(planName)}</th>`;
        });
        html += '</tr></thead><tbody>';

        // Rows: Iterate through procedure elements
        spreadsheetData.rows.forEach(row => {
          html += '<tr>';
          html += `<td>${this.escapeHtml(row.procedure_element)}</td>`;

          // Add value for each plan (should match planUnits array order)
          row.plan_values.forEach(value => {
            html += `<td>${this.escapeHtml(value || 'Not specified')}</td>`;
          });

          html += '</tr>';
        });

        html += '</tbody></table>';
        output.innerHTML = html;
      },

      renderLanguageComparison(languageData, planUnits) {
        const output = document.getElementById('language-output');

        let html = '';
        languageData.rows.forEach(row => {
          html += `<div class="language-row">`;
          html += `<div class="language-row-header">${this.escapeHtml(row.procedure_element)}</div>`;

          // Iterate through plan_details array, using planUnits for names
          row.plan_details.forEach((details, index) => {
            const planName = planUnits[index] || `Plan ${index + 1}`;

            html += `<div class="plan-language">`;
            html += `<div class="plan-name">${this.escapeHtml(planName)}</div>`;
            html += `<div class="plan-summary">${this.escapeHtml(details.summary)}</div>`;
            html += `<div class="plan-full-text">${this.escapeHtml(details.full_text)}</div>`;
            html += `<div class="plan-citation">${this.escapeHtml(details.citation)}</div>`;
            html += `</div>`;
          });

          html += `</div>`;
        });

        output.innerHTML = html;
      },

      // ===== Download Functions =====

      // Convert markdown table to CSV format
      markdownTableToCSV(markdown) {
        const lines = markdown.split('\n');
        const csvLines = [];

        for (const line of lines) {
          // Skip separator lines (|---|---|)
          if (line.match(/^\|[\s\-:]+\|$/)) continue;

          // Process table rows
          if (line.startsWith('|') && line.endsWith('|')) {
            const cells = line
              .slice(1, -1)  // Remove leading/trailing pipes
              .split('|')
              .map(cell => {
                // Clean and escape cell content for CSV
                let content = cell.trim();
                // Escape quotes by doubling them
                content = content.replace(/"/g, '""');
                // Wrap in quotes if contains comma, newline, or quote
                if (content.includes(',') || content.includes('\n') || content.includes('"')) {
                  content = `"${content}"`;
                }
                return content;
              });
            csvLines.push(cells.join(','));
          }
        }

        return csvLines.join('\n');
      },

      downloadSummary() {
        if (!this.state.summaryResponse) return;

        // Download the summary response as plain text
        const content = 'SPD Comparison Summary\n\n' + this.state.summaryResponse;

        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'Summary.txt';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      },

      downloadComparisonSpreadsheet() {
        if (!this.state.comparisonResponse) return;

        // Convert markdown table to CSV
        const csv = this.markdownTableToCSV(this.state.comparisonResponse);

        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'Comparison.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      },

      downloadLanguageComparison() {
        if (!this.state.languageResponse) return;

        // Convert markdown table to CSV
        const csv = this.markdownTableToCSV(this.state.languageResponse);

        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'Citations.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      },

      // ========================================
      // Session History Methods
      // ========================================

      /**
       * Check if running in proxy mode (Cloudflare deployment or wrangler dev)
       * Returns true for both production AND local wrangler dev (http://localhost)
       * Returns false only for file:// protocol (direct file open)
       */
      isProxyMode() {
        // Allow history features when running via wrangler dev (http://localhost)
        // Only skip for file:// protocol (direct file open without server)
        return window.location.protocol !== 'file:';
      },

      /**
       * Load history list on init (only in proxy mode)
       */
      async loadHistoryList() {
        if (!this.isProxyMode()) return;

        try {
          const res = await fetch('/api/history/analyses');
          if (res.ok) {
            const data = await res.json();
            this.state.currentUserEmail = data.current_user_email || null;
            this.state.historyList = data.analyses || [];
            this.state.sharedAnalysesList = data.shared_analyses || [];
            this.updateHistoryBadge();
          }
        } catch (error) {
          console.error('Failed to load history:', error);
        }
      },

      /**
       * Save analysis after Phase 3 completes
       * Uploads files to R2 storage for persistent access
       */
      async saveAnalysis() {
        if (!this.isProxyMode()) return;

        try {
          // Step 1: Create analysis to get ID (with initial metadata)
          const initialMetadata = this.state.uploadedFiles
            .filter(f => f.status === 'uploaded')
            .map(({ filename, size, mimeType, uploadedAt }) => ({
              filename, size, mimeType, uploadedAt
            }));

          const createRes = await fetch('/api/history/analyses', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              title: initialMetadata[0]?.filename || 'Untitled Analysis',
              file_metadata: initialMetadata,
              summary_response: this.state.summaryResponse,
              comparison_response: this.state.comparisonResponse,
              language_response: this.state.languageResponse
            })
          });

          if (!createRes.ok) {
            throw new Error('Failed to create analysis');
          }

          const { id: analysisId } = await createRes.json();
          this.state.currentAnalysisId = analysisId;
          this.state.isOwner = true; // User is owner of newly created analysis
          this.updateShareButtonVisibility();
          console.log('Analysis created:', analysisId);

          // Step 2: Upload files to R2
          const uploadedFiles = this.state.uploadedFiles.filter(f => f.status === 'uploaded');
          const updatedMetadata = [];
          const failedUploads = [];

          for (const file of uploadedFiles) {
            try {
              // Convert base64 back to blob
              const byteCharacters = atob(file.base64Data);
              const byteArray = new Uint8Array(byteCharacters.length);
              for (let i = 0; i < byteCharacters.length; i++) {
                byteArray[i] = byteCharacters.charCodeAt(i);
              }
              const blob = new Blob([byteArray], { type: file.mimeType });

              // Upload to R2
              const formData = new FormData();
              formData.append('file', blob, file.filename);
              formData.append('analysisId', analysisId);

              const uploadRes = await fetch('/api/files', {
                method: 'POST',
                body: formData
              });

              if (uploadRes.ok) {
                const { r2Key, r2Etag } = await uploadRes.json();
                updatedMetadata.push({
                  filename: file.filename,
                  size: file.size,
                  mimeType: file.mimeType,
                  uploadedAt: file.uploadedAt,
                  r2Key,
                  r2Etag
                });
                // Update local state with R2 key
                file.r2Key = r2Key;
                console.log(`Uploaded ${file.filename} to R2:`, r2Key);
              } else {
                console.warn(`Failed to upload ${file.filename} to R2`);
                failedUploads.push(file.filename);
                updatedMetadata.push({
                  filename: file.filename,
                  size: file.size,
                  mimeType: file.mimeType,
                  uploadedAt: file.uploadedAt
                });
              }
            } catch (e) {
              console.error(`Error uploading ${file.filename}:`, e);
              failedUploads.push(file.filename);
              updatedMetadata.push({
                filename: file.filename,
                size: file.size,
                mimeType: file.mimeType,
                uploadedAt: file.uploadedAt
              });
            }
          }

          // Step 3: Update analysis with R2 keys
          if (updatedMetadata.some(f => f.r2Key)) {
            await fetch(`/api/history/analyses/${analysisId}`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ file_metadata: updatedMetadata })
            });
          }

          // Warn user if some uploads failed
          if (failedUploads.length > 0) {
            console.warn(`${failedUploads.length} file(s) couldn't be stored in R2`);
          }

          // Refresh history list
          this.loadHistoryList();

        } catch (error) {
          console.error('Failed to save analysis:', error);
        }
      },

      /**
       * Save chat messages after each response
       */
      async saveChatMessages() {
        if (!this.isProxyMode() || !this.state.currentAnalysisId) return;

        try {
          // Send the last 2 messages (user question + assistant response)
          const lastTwo = this.state.chatMessages.slice(-2);

          await fetch(`/api/history/analyses/${this.state.currentAnalysisId}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ new_messages: lastTwo })
          });
        } catch (error) {
          console.error('Failed to save chat messages:', error);
        }
      },

      /**
       * Load a specific analysis from history
       * Fetches files from R2 storage if available
       */
      async loadAnalysis(analysisId) {
        try {
          const res = await fetch(`/api/history/analyses/${analysisId}`);
          if (!res.ok) {
            throw new Error('Analysis not found');
          }

          const data = await res.json();

          // Reset current state
          this.resetForLoadedAnalysis();

          // Load analysis data
          this.state.currentAnalysisId = data.id;
          this.state.summaryResponse = data.summary_response;
          this.state.comparisonResponse = data.comparison_response;
          this.state.languageResponse = data.language_response;
          this.state.chatMessages = data.chat_messages || [];
          this.state.notes = data.notes || [];
          this.state.isOwner = data.is_owner !== false; // Default to true for backwards compatibility
          this.state.ownerEmail = data.owner_email || null;

          // Parse file_metadata if it's a JSON string (from database)
          let fileMetadata = data.file_metadata || [];
          if (typeof fileMetadata === 'string') {
            try {
              fileMetadata = JSON.parse(fileMetadata);
            } catch (e) {
              console.error('Failed to parse file_metadata:', e);
              fileMetadata = [];
            }
          }

          // Set up files - mark as loading if they have R2 keys
          this.state.uploadedFiles = fileMetadata.map((f, i) => ({
            ...f,
            id: 'hist_' + Date.now() + '_' + i,
            status: f.r2Key ? 'loading' : 'metadata_only',
            base64Data: null
          }));

          // Render the loaded analysis immediately (files show as loading)
          this.renderLoadedAnalysis();

          // Close history panel
          this.toggleHistoryPanel();

          // Fetch files from R2 asynchronously
          for (const file of this.state.uploadedFiles) {
            if (file.r2Key) {
              this.loadFileFromR2(file);
            }
          }

        } catch (error) {
          console.error('Failed to load analysis:', error);
          alert('Failed to load analysis. It may have been deleted.');
          this.loadHistoryList(); // Refresh list
        }
      },

      /**
       * Load a single file from R2 storage
       * Updates file status and base64Data when complete
       */
      async loadFileFromR2(fileObj) {
        try {
          const res = await fetch(`/api/files/${fileObj.r2Key}`);
          if (!res.ok) {
            throw new Error('File not found in storage');
          }

          const blob = await res.blob();

          // Convert blob to base64
          const reader = new FileReader();
          reader.onload = () => {
            const base64 = reader.result.split(',')[1]; // Remove data URL prefix
            fileObj.base64Data = base64;
            fileObj.status = 'uploaded';
            this.renderFilesList();
            console.log(`Loaded ${fileObj.filename} from R2`);
          };

          reader.onerror = () => {
            fileObj.status = 'error';
            fileObj.error = 'Failed to read file data';
            this.renderFilesList();
          };

          reader.readAsDataURL(blob);

        } catch (error) {
          console.error(`Error loading ${fileObj.filename} from R2:`, error);
          fileObj.status = 'error';
          fileObj.error = error.message;
          this.renderFilesList();
        }
      },

      /**
       * Reset state for loading a saved analysis
       */
      resetForLoadedAnalysis() {
        this.state.messages = [];
        this.state.isStreaming = false;
        this.state.currentResponse = '';
        this.state.currentThinking = '';
        this.state.currentPhase = 0;
        this.state.isComparisonRequest = false;
        this.state.isChatStreaming = false;
        this.state.currentChatResponse = '';
      },

      /**
       * Render a loaded analysis (show tabs with content)
       */
      renderLoadedAnalysis() {
        // Update share button visibility (only show if owner)
        this.updateShareButtonVisibility();

        // Hide messages container (empty state)
        document.getElementById('messages').style.display = 'none';

        // Hide the Compare Documents button/input area
        const inputContainer = document.querySelector('.input-container');
        if (inputContainer) {
          inputContainer.style.display = 'none';
        }

        // Collapse the files panel if expanded
        if (this.state.filesPanelExpanded) {
          this.toggleFilesPanel();
        }

        // Show output tabs
        const outputTabs = document.getElementById('output-tabs');
        outputTabs.classList.add('active');

        // Render all three tabs
        this.renderSummaryTab();
        this.renderComparisonTab();
        this.renderLanguageTab();

        // Show split view (chat sidebar)
        const splitView = document.getElementById('split-view');
        splitView.classList.add('active');

        // Handle chat panel state
        const chatPanel = document.getElementById('chat-panel');
        const collapseButton = document.getElementById('collapse-chat-button');
        if (chatPanel && this.state.chatPanelCollapsed) {
          chatPanel.classList.add('collapsed');
          splitView.style.width = '48px';
          if (outputTabs) {
            outputTabs.style.marginRight = '52px';
          }
          if (collapseButton) {
            collapseButton.innerHTML = '‚óÄ';
            collapseButton.title = 'Expand chat panel';
          }
        }

        // Initialize resize handle and collapse button (only once)
        if (!this._resizeHandleInitialized) {
          this.initResizeHandle();
          this._resizeHandleInitialized = true;
        }

        // Initialize chat
        this.initChatEventListeners();
        this.renderMiniResultPanel(this.state.chatPanelResultTab);

        // Render existing chat messages
        if (this.state.chatMessages.length > 0) {
          this.renderChatMessages();
        }

        // Show re-upload warning if files were part of analysis
        if (this.state.uploadedFiles.length > 0) {
          this.showReuploadNotice();
        }
      },

      /**
       * Show notice that PDFs need re-upload for continued chat
       */
      showReuploadNotice() {
        const filesPanel = document.getElementById('files-panel');
        if (!filesPanel) return;

        // Check if notice already exists
        if (document.getElementById('reupload-notice')) return;

        const notice = document.createElement('div');
        notice.id = 'reupload-notice';
        notice.className = 'reupload-notice';
        notice.innerHTML = `
          <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="12" y1="8" x2="12" y2="12"></line>
            <line x1="12" y1="16" x2="12.01" y2="16"></line>
          </svg>
          <span>To continue chatting, re-upload the original PDF files.</span>
        `;
        filesPanel.insertBefore(notice, filesPanel.firstChild);
      },

      /**
       * Toggle history panel visibility
       */
      toggleHistoryPanel() {
        this.state.historyPanelOpen = !this.state.historyPanelOpen;
        const panel = document.getElementById('history-panel');
        if (panel) {
          panel.classList.toggle('open', this.state.historyPanelOpen);
        }
        if (this.state.historyPanelOpen) {
          this.renderHistoryPanel();
        }
      },

      /**
       * Update history badge count
       */
      updateHistoryBadge() {
        const badge = document.getElementById('history-badge');
        if (badge) {
          const count = this.state.historyList.length;
          badge.textContent = count;
          badge.style.display = count > 0 ? 'flex' : 'none';
        }
      },

      /**
       * Render the history panel content
       */
      renderHistoryPanel() {
        const content = document.getElementById('history-content');
        if (!content) return;

        // Show/hide New Analysis button based on whether we're in a saved session
        const newAnalysisBtn = document.getElementById('new-analysis-button');
        if (newAnalysisBtn) {
          newAnalysisBtn.style.display = this.state.currentAnalysisId ? 'flex' : 'none';
        }

        const hasOwned = this.state.historyList.length > 0;
        const hasShared = this.state.sharedAnalysesList.length > 0;

        if (!hasOwned && !hasShared) {
          content.innerHTML = `
            <div class="history-empty">
              <svg viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.5">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12 6 12 12 16 14"></polyline>
              </svg>
              <p>No saved analyses yet</p>
              <p class="history-empty-hint">Run a comparison to save it here</p>
            </div>
          `;
          return;
        }

        let html = '';

        // Render owned analyses
        if (hasOwned) {
          if (hasShared) {
            html += '<div class="history-section-label">My Analyses</div>';
          }
          const grouped = this.groupHistoryByDate(this.state.historyList);
          html += this.renderHistoryCards(grouped, true);
        }

        // Render shared analyses
        if (hasShared) {
          html += '<div class="history-section-label" style="margin-top: 24px;">Shared with Me</div>';
          const grouped = this.groupHistoryByDate(this.state.sharedAnalysesList);
          html += this.renderHistoryCards(grouped, false);
        }

        content.innerHTML = html;
      },

      /**
       * Render history cards for a grouped list
       */
      renderHistoryCards(grouped, isOwned) {
        let html = '';
        for (const [dateLabel, items] of Object.entries(grouped)) {
          html += `<div class="history-date-group">
            <div class="history-date-label">${dateLabel}</div>`;

          for (const item of items) {
            // Parse file_metadata if it's a JSON string (from database)
            let fileMetadata = item.file_metadata || [];
            if (typeof fileMetadata === 'string') {
              try {
                fileMetadata = JSON.parse(fileMetadata);
              } catch (e) {
                fileMetadata = [];
              }
            }
            const fileCount = fileMetadata.length;
            const time = new Date(item.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const title = this.truncateTitle(item.title || 'Untitled', 40);
            const fullTitle = item.title || 'Untitled';

            html += `
              <div class="history-card ${isOwned ? '' : 'shared'}" data-id="${item.id}">
                <div class="history-card-header">
                  <div class="history-card-title" onclick="ChatApp.loadAnalysis('${item.id}')" title="${this.escapeHtml(fullTitle)}">${this.escapeHtml(title)}</div>
                  ${isOwned ? `
                  <button class="history-edit-btn" onclick="event.stopPropagation(); ChatApp.editAnalysisTitle('${item.id}', '${this.escapeHtml(fullTitle).replace(/'/g, "\\'")}');" title="Rename">
                    <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                      <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                    </svg>
                  </button>
                  ` : ''}
                </div>
                ${!isOwned && item.owner_email ? `
                <div class="history-card-owner" onclick="ChatApp.loadAnalysis('${item.id}')">
                  Shared by ${this.escapeHtml(item.owner_email)}
                </div>
                ` : ''}
                <div class="history-card-meta" onclick="ChatApp.loadAnalysis('${item.id}')">
                  <span>${fileCount} file${fileCount !== 1 ? 's' : ''}</span>
                  <span>‚Ä¢</span>
                  <span>${time}</span>
                </div>
              </div>
            `;
          }
          html += '</div>';
        }
        return html;
      },

      /**
       * Group history items by date
       */
      groupHistoryByDate(items) {
        const groups = {};
        const today = new Date().toDateString();
        const yesterday = new Date(Date.now() - 86400000).toDateString();

        for (const item of items) {
          const date = new Date(item.created_at).toDateString();
          let label;

          if (date === today) {
            label = 'Today';
          } else if (date === yesterday) {
            label = 'Yesterday';
          } else {
            label = new Date(item.created_at).toLocaleDateString([], {
              month: 'short', day: 'numeric', year: 'numeric'
            });
          }

          if (!groups[label]) groups[label] = [];
          groups[label].push(item);
        }

        return groups;
      },

      /**
       * Truncate title with ellipsis
       */
      truncateTitle(title, maxLen) {
        if (title.length <= maxLen) return title;
        return title.substring(0, maxLen - 3) + '...';
      },

      /**
       * Open rename modal for an analysis
       */
      editAnalysisTitle(analysisId, currentTitle) {
        this.state.renamingAnalysisId = analysisId;
        const modal = document.getElementById('rename-modal');
        const input = document.getElementById('rename-input');
        input.value = currentTitle;
        modal.style.display = 'flex';
        input.focus();
        input.select();
      },

      /**
       * Close the rename modal
       */
      closeRenameModal() {
        const modal = document.getElementById('rename-modal');
        modal.style.display = 'none';
        this.state.renamingAnalysisId = null;
      },

      /**
       * Confirm the rename action
       */
      async confirmRename() {
        const input = document.getElementById('rename-input');
        const newTitle = input.value.trim();
        const analysisId = this.state.renamingAnalysisId;

        if (!analysisId || !newTitle) {
          return;
        }

        try {
          const res = await fetch(`/api/history/analyses/${analysisId}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title: newTitle })
          });

          if (res.ok) {
            // Update local state
            const item = this.state.historyList.find(a => a.id === analysisId);
            if (item) {
              item.title = newTitle;
            }
            // Re-render the history panel
            this.renderHistoryPanel();
            this.closeRenameModal();
          } else {
            alert('Failed to rename analysis');
          }
        } catch (error) {
          console.error('Error renaming analysis:', error);
          alert('Failed to rename analysis');
        }
      },

      /**
       * Start a new analysis (reset to initial state)
       */
      startNewAnalysis() {
        // Clear current analysis ID
        this.state.currentAnalysisId = null;

        // Reset all analysis-related state
        this.state.messages = [];
        this.state.summaryResponse = null;
        this.state.comparisonResponse = null;
        this.state.languageResponse = null;
        this.state.chatMessages = [];
        this.state.notes = [];
        this.state.currentPhase = 0;
        this.state.isStreaming = false;
        this.state.isChatStreaming = false;
        this.state.currentResponse = '';
        this.state.currentChatResponse = '';
        this.state.isComparisonRequest = false;

        // Reset sharing state
        this.state.isOwner = true;
        this.state.ownerEmail = null;

        // Clear uploaded files
        this.state.uploadedFiles = [];

        // Hide output tabs and split view
        const outputTabs = document.getElementById('output-tabs');
        const splitView = document.getElementById('split-view');
        if (outputTabs) {
          outputTabs.classList.remove('active');
          outputTabs.style.marginRight = '';
        }
        if (splitView) {
          splitView.classList.remove('active');
          splitView.classList.remove('expanded');
        }

        // Show messages container (initial state)
        const messagesContainer = document.getElementById('messages');
        if (messagesContainer) {
          messagesContainer.style.display = '';
          // Restore empty state
          messagesContainer.innerHTML = `
            <div class="empty-state">
              <h2>Ready to compare plan documents</h2>
              <p>Upload your PDF files above and click "Compare Documents" to begin analysis.</p>
            </div>
          `;
        }

        // Show input container with Compare button
        const inputContainer = document.querySelector('.input-container');
        if (inputContainer) {
          inputContainer.style.display = '';
        }

        // Expand files panel
        if (!this.state.filesPanelExpanded) {
          this.toggleFilesPanel();
        }

        // Re-render input area and files list
        this.renderInputArea();
        this.renderFilesList();

        // Update history panel (hide New Analysis button)
        this.renderHistoryPanel();

        // Hide share button (no analysis loaded)
        this.updateShareButtonVisibility();

        // Close history panel
        this.toggleHistoryPanel();
      },

      // ========================================
      // SHARING FEATURE METHODS
      // ========================================

      /**
       * Open share modal
       */
      async openShareModal() {
        if (!this.state.currentAnalysisId || !this.state.isOwner) {
          alert('You can only share analyses you own.');
          return;
        }

        await this.loadShares();
        this.state.shareModalOpen = true;
        document.getElementById('share-modal').style.display = 'flex';
        this.renderShareModal();
      },

      /**
       * Close share modal
       */
      closeShareModal() {
        this.state.shareModalOpen = false;
        document.getElementById('share-modal').style.display = 'none';
        this.state.shareInputEmail = '';
        document.getElementById('share-email').value = '';
      },

      /**
       * Load current shares for the analysis
       */
      async loadShares() {
        if (!this.state.currentAnalysisId) return;

        try {
          const res = await fetch(`/api/history/analyses/${this.state.currentAnalysisId}/shares`);
          if (res.ok) {
            this.state.currentShares = await res.json();
          }
        } catch (error) {
          console.error('Failed to load shares:', error);
        }
      },

      /**
       * Render share modal content
       */
      renderShareModal() {
        // Render email shares
        const emailList = document.getElementById('email-shares-list');
        if (emailList) {
          if (this.state.currentShares.email_shares.length === 0) {
            emailList.innerHTML = '';
          } else {
            emailList.innerHTML = this.state.currentShares.email_shares.map(share => `
              <div class="share-item" data-id="${share.id}">
                <div class="share-item-info">
                  <div class="share-item-email">${this.escapeHtml(share.shared_with_email)}</div>
                  <div class="share-item-meta">${share.shared_with_id ? 'Accepted' : 'Pending'}</div>
                </div>
                <div class="share-item-actions">
                  <button class="share-item-btn delete" onclick="ChatApp.revokeShare('${share.id}', 'email')" title="Revoke access">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <polyline points="3 6 5 6 21 6"></polyline>
                      <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                  </button>
                </div>
              </div>
            `).join('');
          }
        }

        // Render link shares
        const linkList = document.getElementById('link-shares-list');
        if (linkList) {
          if (this.state.currentShares.link_shares.length === 0) {
            linkList.innerHTML = '';
          } else {
            linkList.innerHTML = this.state.currentShares.link_shares.map(share => `
              <div class="share-item" data-id="${share.id}">
                <div class="share-item-info">
                  <div class="share-item-url">${this.escapeHtml(share.url)}</div>
                  <div class="share-item-meta">
                    ${share.use_count} use${share.use_count !== 1 ? 's' : ''}
                    ${share.expires_at ? ' ‚Ä¢ Expires ' + new Date(share.expires_at).toLocaleDateString() : ''}
                  </div>
                </div>
                <div class="share-item-actions">
                  <button class="share-item-btn" onclick="ChatApp.copyShareLink('${share.url}')" title="Copy link">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                  </button>
                  <button class="share-item-btn delete" onclick="ChatApp.revokeShare('${share.id}', 'link')" title="Revoke link">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <polyline points="3 6 5 6 21 6"></polyline>
                      <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                  </button>
                </div>
              </div>
            `).join('');
          }
        }
      },

      /**
       * Add email share
       */
      async addEmailShare() {
        const input = document.getElementById('share-email');
        const email = input.value.trim();

        if (!email) {
          alert('Please enter an email address.');
          return;
        }

        if (!email.includes('@')) {
          alert('Please enter a valid email address.');
          return;
        }

        try {
          const res = await fetch(`/api/history/analyses/${this.state.currentAnalysisId}/shares`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ type: 'email', email })
          });

          if (res.ok) {
            input.value = '';
            await this.loadShares();
            this.renderShareModal();
          } else {
            const data = await res.json();
            alert(data.error || 'Failed to share.');
          }
        } catch (error) {
          console.error('Failed to add email share:', error);
          alert('Failed to share. Please try again.');
        }
      },

      /**
       * Create shareable link
       */
      async createShareLink() {
        try {
          const res = await fetch(`/api/history/analyses/${this.state.currentAnalysisId}/shares`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ type: 'link' })
          });

          if (res.ok) {
            const data = await res.json();
            await navigator.clipboard.writeText(data.url);
            alert('Link copied to clipboard!');
            await this.loadShares();
            this.renderShareModal();
          } else {
            const data = await res.json();
            alert(data.error || 'Failed to create share link.');
          }
        } catch (error) {
          console.error('Failed to create share link:', error);
          alert('Failed to create link. Please try again.');
        }
      },

      /**
       * Copy share link to clipboard
       */
      async copyShareLink(url) {
        try {
          await navigator.clipboard.writeText(url);
          alert('Link copied to clipboard!');
        } catch (error) {
          console.error('Failed to copy:', error);
        }
      },

      /**
       * Update share button visibility
       */
      updateShareButtonVisibility() {
        const shareBtn = document.getElementById('share-button');
        if (shareBtn) {
          // Show share button only if we have a saved analysis and user is owner
          const shouldShow = this.state.currentAnalysisId && this.state.isOwner;
          shareBtn.style.display = shouldShow ? 'flex' : 'none';
        }
      },

      /**
       * Revoke a share
       */
      async revokeShare(shareId, shareType) {
        if (!confirm('Revoke this access?')) return;

        try {
          const res = await fetch(`/api/history/analyses/${this.state.currentAnalysisId}/shares`, {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ share_id: shareId, share_type: shareType })
          });

          if (res.ok) {
            await this.loadShares();
            this.renderShareModal();
          } else {
            alert('Failed to revoke access.');
          }
        } catch (error) {
          console.error('Failed to revoke share:', error);
          alert('Failed to revoke access. Please try again.');
        }
      },

      // ========================================
      // NOTES FEATURE METHODS
      // ========================================

      /**
       * Initialize note-related event listeners
       */
      initNoteEvents() {
        // Text selection in output tabs
        ['summary-output', 'comparison-output', 'language-output'].forEach(id => {
          const el = document.getElementById(id);
          if (!el) return;

          el.addEventListener('mouseup', (e) => {
            // Don't show hint if clicking on an existing highlight
            if (e.target.closest('.note-highlight')) return;

            const tab = id.replace('-output', '');
            const selection = this.captureTextSelection(tab);
            if (selection) {
              this.state.pendingSelection = selection;
              this.showSelectionHint(selection.rect);
            } else {
              this.hideSelectionHint();
              this.state.pendingSelection = null;
            }
          });
        });

        // Click on highlights to open popup
        document.addEventListener('click', (e) => {
          const highlight = e.target.closest('.note-highlight');
          if (highlight) {
            e.preventDefault();
            e.stopPropagation();
            this.hideSelectionHint();
            this.openNotePopup(highlight.dataset.noteId, highlight.getBoundingClientRect());
          }
        });

        // Close popup on outside click
        document.addEventListener('mousedown', (e) => {
          if (this.state.isNotePopupOpen) {
            const popup = document.getElementById('note-popup');
            const hint = document.getElementById('selection-hint');
            if (!popup.contains(e.target) && !e.target.closest('.note-highlight') && !hint?.contains(e.target)) {
              this.closeNotePopup();
            }
          }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          // Escape to close popup
          if (e.key === 'Escape' && this.state.isNotePopupOpen) {
            this.closeNotePopup();
          }

          // Ctrl/Cmd + Enter to save note/reply in editor
          if ((e.ctrlKey || e.metaKey) && e.key === 'Enter' && this.state.isNotePopupOpen) {
            if (this.state.replyingToNoteId) {
              e.preventDefault();
              this.submitReply();
            } else if (this.state.isEditingNote) {
              e.preventDefault();
              this.saveCurrentNote();
            }
          }
        });

        // Hide selection hint on scroll (position becomes invalid)
        document.addEventListener('scroll', () => {
          this.hideSelectionHint();
          this.state.pendingSelection = null;
        }, true);

        // Hide selection hint when clicking elsewhere
        document.addEventListener('mousedown', (e) => {
          const hint = document.getElementById('selection-hint');
          if (hint && hint.style.display !== 'none' && !hint.contains(e.target)) {
            // Small delay to allow "Add Note" click to process first
            setTimeout(() => {
              if (this.state.pendingSelection) {
                this.hideSelectionHint();
                this.state.pendingSelection = null;
              }
            }, 100);
          }
        });
      },

      /**
       * Capture the current text selection and return anchor data
       */
      captureTextSelection(tab) {
        const selection = window.getSelection();
        if (!selection || selection.isCollapsed) return null;

        const selectedText = selection.toString().trim();
        if (!selectedText || selectedText.length < 3) return null;

        const outputDiv = document.getElementById(`${tab}-output`);
        if (!outputDiv) return null;

        const fullText = outputDiv.textContent;
        const idx = fullText.indexOf(selectedText);
        if (idx === -1) return null;

        // Extract prefix/suffix context (50 chars each)
        const prefix = fullText.substring(Math.max(0, idx - 50), idx);
        const suffix = fullText.substring(idx + selectedText.length, idx + selectedText.length + 50);

        return {
          text: selectedText,
          prefix: prefix,
          suffix: suffix,
          tab: tab,
          rect: selection.getRangeAt(0).getBoundingClientRect()
        };
      },

      /**
       * Escape special regex characters in a string
       */
      escapeRegex(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      },

      /**
       * Calculate similarity score between two strings (0-1)
       */
      similarity(str1, str2) {
        if (!str1 || !str2) return 0;
        const maxLen = Math.max(str1.length, str2.length);
        if (maxLen === 0) return 1;

        // Simple character-by-character comparison
        let matches = 0;
        const minLen = Math.min(str1.length, str2.length);
        for (let i = 0; i < minLen; i++) {
          if (str1[i] === str2[i]) matches++;
        }
        return matches / maxLen;
      },

      /**
       * Find the position of a note's anchor text in the content
       */
      findAnchorPosition(note, outputDiv) {
        const fullText = outputDiv.textContent;
        const { anchor_text, anchor_prefix, anchor_suffix } = note;

        // Find all occurrences of anchor_text
        const occurrences = [];
        let pos = 0;
        while ((pos = fullText.indexOf(anchor_text, pos)) !== -1) {
          occurrences.push(pos);
          pos += 1;
        }

        if (occurrences.length === 0) return null;
        if (occurrences.length === 1) return occurrences[0];

        // Disambiguate using prefix/suffix similarity
        let bestMatch = occurrences[0];
        let bestScore = 0;

        for (const pos of occurrences) {
          let score = 0;

          // Check prefix match
          if (anchor_prefix) {
            const actualPrefix = fullText.substring(Math.max(0, pos - anchor_prefix.length), pos);
            score += this.similarity(actualPrefix, anchor_prefix);
          }

          // Check suffix match
          if (anchor_suffix) {
            const actualSuffix = fullText.substring(
              pos + anchor_text.length,
              pos + anchor_text.length + (anchor_suffix?.length || 50)
            );
            score += this.similarity(actualSuffix, anchor_suffix);
          }

          if (score > bestScore) {
            bestScore = score;
            bestMatch = pos;
          }
        }

        return bestMatch;
      },

      /**
       * Create a Range at a specific text position
       */
      createRangeAtPosition(outputDiv, position, length) {
        const walker = document.createTreeWalker(
          outputDiv,
          NodeFilter.SHOW_TEXT,
          null,
          false
        );

        let currentPos = 0;
        let node;
        let startNode = null, startOffset = 0;
        let endNode = null, endOffset = 0;
        const endPosition = position + length;

        while ((node = walker.nextNode())) {
          const nodeLen = node.textContent.length;

          // Find start node
          if (!startNode && currentPos + nodeLen > position) {
            startNode = node;
            startOffset = position - currentPos;
          }

          // Find end node
          if (currentPos + nodeLen >= endPosition) {
            endNode = node;
            endOffset = endPosition - currentPos;
            break;
          }

          currentPos += nodeLen;
        }

        if (!startNode || !endNode) return null;

        try {
          const range = document.createRange();
          range.setStart(startNode, startOffset);
          range.setEnd(endNode, endOffset);
          return range;
        } catch (e) {
          console.warn('Failed to create range:', e);
          return null;
        }
      },

      /**
       * Apply note highlights to a tab's content
       */
      applyNoteHighlights(tab) {
        const outputDiv = document.getElementById(`${tab}-output`);
        if (!outputDiv) return;

        const tabNotes = this.state.notes.filter(n => n.tab === tab);

        // Clear existing highlights
        outputDiv.querySelectorAll('.note-highlight').forEach(el => {
          const text = el.textContent;
          el.replaceWith(document.createTextNode(text));
        });

        // Normalize to merge adjacent text nodes
        outputDiv.normalize();

        // Apply each note's highlight (sort by position to handle overlaps)
        const notesWithPositions = tabNotes.map(note => ({
          note,
          position: this.findAnchorPosition(note, outputDiv)
        })).filter(n => n.position !== null)
          .sort((a, b) => b.position - a.position); // Reverse order to preserve positions

        for (const { note, position } of notesWithPositions) {
          const range = this.createRangeAtPosition(outputDiv, position, note.anchor_text.length);
          if (!range) continue;

          try {
            const mark = document.createElement('mark');
            mark.className = 'note-highlight';
            mark.dataset.noteId = note.id;
            mark.title = 'Click to view note';
            range.surroundContents(mark);
          } catch (e) {
            // If selection spans multiple elements, try extractContents approach
            try {
              const mark = document.createElement('mark');
              mark.className = 'note-highlight';
              mark.dataset.noteId = note.id;
              mark.title = 'Click to view note';
              const fragment = range.extractContents();
              mark.appendChild(fragment);
              range.insertNode(mark);
            } catch (e2) {
              console.warn(`Could not highlight note ${note.id}:`, e2);
            }
          }
        }
      },

      /**
       * Show the selection hint tooltip near the selection
       */
      showSelectionHint(rect) {
        const hint = document.getElementById('selection-hint');
        if (!hint) return;

        // Position below and centered on selection
        let left = rect.left + (rect.width / 2) - 50; // Approximate hint width / 2
        let top = rect.bottom + 8;

        // Viewport bounds check
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        if (left < 16) left = 16;
        if (left + 100 > viewportWidth - 16) left = viewportWidth - 116;
        if (top + 40 > viewportHeight - 16) top = rect.top - 40;

        hint.style.left = `${left}px`;
        hint.style.top = `${top}px`;
        hint.style.display = 'block';
      },

      /**
       * Hide the selection hint tooltip
       */
      hideSelectionHint() {
        const hint = document.getElementById('selection-hint');
        if (hint) {
          hint.style.display = 'none';
        }
      },

      /**
       * Add a note from the current text selection
       */
      addNoteFromSelection() {
        const selection = this.state.pendingSelection;
        if (!selection) return;

        this.hideSelectionHint();

        // Check if analysis is saved (has ID)
        if (!this.state.currentAnalysisId) {
          alert('Please save the analysis first before adding notes. Notes will be saved automatically after the comparison completes.');
          return;
        }

        // Create a temporary note
        const tempId = 'temp_' + Date.now();
        const note = {
          id: tempId,
          _tempId: tempId,
          tab: selection.tab,
          anchor_text: selection.text,
          anchor_prefix: selection.prefix,
          anchor_suffix: selection.suffix,
          content: '',
          created_at: new Date().toISOString()
        };

        // Add to state
        this.state.notes.push(note);

        // Apply highlight immediately
        this.applyNoteHighlights(selection.tab);

        // Open popup in edit mode
        this.state.activeNoteId = tempId;
        this.state.isEditingNote = true;
        this.state.editingNoteContent = '';

        this.openNotePopup(tempId, selection.rect);

        // Clear selection
        window.getSelection()?.removeAllRanges();
        this.state.pendingSelection = null;
      },

      /**
       * Open the note popup for viewing/editing
       */
      openNotePopup(noteId, rect) {
        const popup = document.getElementById('note-popup');
        if (!popup) return;

        const note = this.state.notes.find(n => n.id === noteId || n._tempId === noteId);
        if (!note) return;

        this.state.activeNoteId = noteId;
        this.state.isNotePopupOpen = true;

        // If it's a new note (no content), start in edit mode
        if (!note.content) {
          this.state.isEditingNote = true;
          this.state.editingNoteContent = '';
        } else {
          this.state.isEditingNote = false;
          this.state.editingNoteContent = note.content;
        }

        // Render popup content
        this.renderNotePopupContent();

        // Position popup
        popup.style.display = 'flex';

        // Use setTimeout to get accurate dimensions after display
        setTimeout(() => {
          const popupRect = popup.getBoundingClientRect();
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;

          let left = rect.left + (rect.width / 2) - (popupRect.width / 2);
          let top = rect.bottom + 12;

          // Horizontal bounds check
          if (left < 16) left = 16;
          if (left + popupRect.width > viewportWidth - 16) {
            left = viewportWidth - popupRect.width - 16;
          }

          // Vertical bounds check - show above if not enough room below
          if (top + popupRect.height > viewportHeight - 16) {
            top = rect.top - popupRect.height - 12;
          }

          // Ensure not off-screen at top
          if (top < 16) top = 16;

          popup.style.left = `${left}px`;
          popup.style.top = `${top}px`;

          // Focus editor if in edit mode
          if (this.state.isEditingNote) {
            const editor = document.getElementById('note-editor');
            if (editor) editor.focus();
          }
        }, 10);

        // Mark the highlight as active
        document.querySelectorAll('.note-highlight').forEach(el => el.classList.remove('active'));
        const highlight = document.querySelector(`.note-highlight[data-note-id="${noteId}"]`);
        if (highlight) highlight.classList.add('active');
      },

      /**
       * Close the note popup
       */
      closeNotePopup() {
        const popup = document.getElementById('note-popup');
        if (popup) {
          popup.style.display = 'none';
        }

        // Remove active class from highlights
        document.querySelectorAll('.note-highlight').forEach(el => el.classList.remove('active'));

        // If we're closing a new note without content, remove it
        if (this.state.activeNoteId) {
          const note = this.state.notes.find(n => n.id === this.state.activeNoteId || n._tempId === this.state.activeNoteId);
          if (note && !note.content && note._tempId) {
            // Remove unsaved empty note
            this.state.notes = this.state.notes.filter(n => n._tempId !== note._tempId);
            this.applyNoteHighlights(note.tab);
          }
        }

        this.state.isNotePopupOpen = false;
        this.state.activeNoteId = null;
        this.state.isEditingNote = false;
        this.state.editingNoteContent = '';
        this.state.replyingToNoteId = null;
      },

      /**
       * Render the content of the note popup (edit or view mode)
       */
      renderNotePopupContent() {
        const content = document.getElementById('note-popup-content');
        const footer = document.getElementById('note-popup-footer');
        if (!content || !footer) return;

        const note = this.state.notes.find(n => n.id === this.state.activeNoteId || n._tempId === this.state.activeNoteId);
        if (!note) return;

        // Check if current user is the author
        const isAuthor = !note.author_email ||
          (this.state.currentUserEmail && note.author_email.toLowerCase() === this.state.currentUserEmail.toLowerCase());

        // Update delete button visibility in header
        const deleteBtn = document.querySelector('.note-popup-btn.delete');
        if (deleteBtn) {
          deleteBtn.style.display = isAuthor ? '' : 'none';
        }

        if (this.state.isEditingNote) {
          content.className = 'note-popup-content editing';
          content.innerHTML = `
            <textarea id="note-editor" class="note-editor" placeholder="Add your note here... (Markdown supported)">${this.escapeHtml(this.state.editingNoteContent)}</textarea>
          `;
          footer.style.display = 'flex';

          // Sync textarea changes to state
          const editor = document.getElementById('note-editor');
          if (editor) {
            editor.addEventListener('input', (e) => {
              this.state.editingNoteContent = e.target.value;
            });
          }
        } else if (this.state.replyingToNoteId === note.id) {
          // Reply mode
          content.className = 'note-popup-content editing';
          content.innerHTML = `
            ${note.author_email ? `<div class="note-author">By: ${this.escapeHtml(note.author_email)}</div>` : ''}
            <div class="note-rendered">${marked.parse(note.content || '')}</div>
            <div class="note-reply-divider">Reply:</div>
            <textarea id="reply-editor" class="note-editor reply-editor" placeholder="Write your reply... (Markdown supported)">${this.escapeHtml(this.state.editingNoteContent)}</textarea>
          `;
          footer.innerHTML = `
            <button class="note-cancel-btn" onclick="ChatApp.cancelReply()">Cancel</button>
            <button class="note-save-btn" onclick="ChatApp.submitReply()">Reply</button>
          `;
          footer.style.display = 'flex';

          // Sync textarea changes to state
          const editor = document.getElementById('reply-editor');
          if (editor) {
            editor.addEventListener('input', (e) => {
              this.state.editingNoteContent = e.target.value;
            });
            editor.focus();
          }
        } else {
          content.className = 'note-popup-content';
          const renderedContent = marked.parse(note.content || '');
          const timestamp = note.created_at ? new Date(note.created_at).toLocaleString() : '';

          // Build actions HTML (only show edit/delete if user is author)
          let actionsHtml = '';
          if (isAuthor) {
            actionsHtml = `<button class="note-edit-btn" onclick="ChatApp.startEditingNote()">Edit</button>`;
          }
          actionsHtml += `<button class="note-reply-btn" onclick="ChatApp.startReply('${note.id}')">Reply</button>`;

          // Render replies if any
          const repliesHtml = this.renderNoteReplies(note.replies || []);

          content.innerHTML = `
            ${note.author_email ? `<div class="note-author">By: ${this.escapeHtml(note.author_email)}</div>` : ''}
            <div class="note-rendered">${renderedContent}</div>
            <div class="note-actions">${actionsHtml}</div>
            ${timestamp ? `<div class="note-timestamp">Created: ${timestamp}</div>` : ''}
            ${repliesHtml}
          `;

          // Restore default footer buttons but update delete visibility
          footer.innerHTML = `
            <button class="note-cancel-btn" onclick="ChatApp.cancelNoteEdit()">Cancel</button>
            <button class="note-save-btn" onclick="ChatApp.saveCurrentNote()">Save</button>
          `;
          footer.style.display = 'none';
        }
      },

      /**
       * Render threaded replies for a note
       */
      renderNoteReplies(replies) {
        if (!replies || replies.length === 0) return '';

        const repliesHtml = replies.map(reply => {
          const isAuthor = !reply.author_email ||
            (this.state.currentUserEmail && reply.author_email.toLowerCase() === this.state.currentUserEmail.toLowerCase());
          const timestamp = reply.created_at ? new Date(reply.created_at).toLocaleString() : '';

          return `
            <div class="note-reply" data-reply-id="${reply.id}">
              ${reply.author_email ? `<div class="reply-author">${this.escapeHtml(reply.author_email)}</div>` : ''}
              <div class="reply-content">${marked.parse(reply.content || '')}</div>
              <div class="reply-meta">
                ${timestamp ? `<span class="reply-timestamp">${timestamp}</span>` : ''}
                ${isAuthor ? `<button class="reply-delete-btn" onclick="ChatApp.deleteReply('${reply.id}')">Delete</button>` : ''}
              </div>
            </div>
          `;
        }).join('');

        return `<div class="note-replies"><div class="replies-header">Replies (${replies.length})</div>${repliesHtml}</div>`;
      },

      /**
       * Start replying to a note
       */
      startReply(noteId) {
        this.state.replyingToNoteId = noteId;
        this.state.editingNoteContent = '';
        this.renderNotePopupContent();
      },

      /**
       * Cancel replying
       */
      cancelReply() {
        this.state.replyingToNoteId = null;
        this.state.editingNoteContent = '';
        this.renderNotePopupContent();
      },

      /**
       * Submit a reply to a note
       */
      async submitReply() {
        const content = this.state.editingNoteContent.trim();
        if (!content) {
          alert('Reply cannot be empty');
          return;
        }

        const parentNoteId = this.state.replyingToNoteId;
        const parentNote = this.state.notes.find(n => n.id === parentNoteId);
        if (!parentNote) return;

        try {
          const res = await fetch(`/api/history/analyses/${this.state.currentAnalysisId}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              add_reply: {
                parent_note_id: parentNoteId,
                content: content
              }
            })
          });

          if (res.ok) {
            const data = await res.json();
            // Add reply to local state
            if (!parentNote.replies) parentNote.replies = [];
            parentNote.replies.push({
              id: data.reply_id,
              content: content,
              author_email: this.state.currentUserEmail,
              created_at: data.created_at
            });

            this.state.replyingToNoteId = null;
            this.state.editingNoteContent = '';
            this.renderNotePopupContent();
          } else {
            const error = await res.json();
            alert('Failed to add reply: ' + (error.error || 'Unknown error'));
          }
        } catch (error) {
          console.error('Error adding reply:', error);
          alert('Failed to add reply');
        }
      },

      /**
       * Delete a reply
       */
      async deleteReply(replyId) {
        if (!confirm('Delete this reply?')) return;

        try {
          const res = await fetch(`/api/history/analyses/${this.state.currentAnalysisId}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              delete_note: { note_id: replyId }
            })
          });

          if (res.ok) {
            // Remove reply from local state
            for (const note of this.state.notes) {
              if (note.replies) {
                note.replies = note.replies.filter(r => r.id !== replyId);
              }
            }
            this.renderNotePopupContent();
          } else {
            alert('Failed to delete reply');
          }
        } catch (error) {
          console.error('Error deleting reply:', error);
          alert('Failed to delete reply');
        }
      },

      /**
       * Start editing the current note
       */
      startEditingNote() {
        const note = this.state.notes.find(n => n.id === this.state.activeNoteId || n._tempId === this.state.activeNoteId);
        if (!note) return;

        this.state.isEditingNote = true;
        this.state.editingNoteContent = note.content || '';
        this.renderNotePopupContent();

        // Focus editor
        setTimeout(() => {
          const editor = document.getElementById('note-editor');
          if (editor) {
            editor.focus();
            editor.setSelectionRange(editor.value.length, editor.value.length);
          }
        }, 10);
      },

      /**
       * Save the current note
       */
      async saveCurrentNote() {
        const noteId = this.state.activeNoteId;
        const content = this.state.editingNoteContent.trim();

        if (!content) {
          alert('Note content cannot be empty');
          return;
        }

        const noteIndex = this.state.notes.findIndex(n => n.id === noteId || n._tempId === noteId);
        if (noteIndex === -1) return;

        const note = this.state.notes[noteIndex];
        const isNew = !!note._tempId;

        // Update local state
        this.state.notes[noteIndex].content = content;

        // Save to backend
        const success = await this.saveNoteToBackend(note, isNew);

        if (success) {
          this.state.isEditingNote = false;
          this.renderNotePopupContent();
        } else {
          alert('Failed to save note. Please try again.');
        }
      },

      /**
       * Cancel editing and revert
       */
      cancelNoteEdit() {
        const note = this.state.notes.find(n => n.id === this.state.activeNoteId || n._tempId === this.state.activeNoteId);

        if (note && !note.content && note._tempId) {
          // New note with no content - remove it
          this.closeNotePopup();
        } else if (note) {
          // Existing note - revert to view mode
          this.state.isEditingNote = false;
          this.state.editingNoteContent = note.content || '';
          this.renderNotePopupContent();
        }
      },

      /**
       * Delete the current note
       */
      async deleteCurrentNote() {
        const noteId = this.state.activeNoteId;
        const note = this.state.notes.find(n => n.id === noteId || n._tempId === noteId);

        if (!note) return;

        if (!confirm('Delete this note?')) return;

        const tab = note.tab;

        // If it's a temp note, just remove locally
        if (note._tempId) {
          this.state.notes = this.state.notes.filter(n => n._tempId !== note._tempId);
        } else {
          // Delete from backend
          const success = await this.deleteNoteFromBackend(note.id);
          if (!success) {
            alert('Failed to delete note. Please try again.');
            return;
          }
          this.state.notes = this.state.notes.filter(n => n.id !== note.id);
        }

        this.closeNotePopup();
        this.applyNoteHighlights(tab);
      },

      /**
       * Save note to backend via API
       */
      async saveNoteToBackend(note, isNew) {
        if (!this.state.currentAnalysisId) {
          console.warn('Cannot save note: no analysis ID');
          return false;
        }

        try {
          const body = isNew ? {
            add_note: {
              tab: note.tab,
              anchor_text: note.anchor_text,
              anchor_prefix: note.anchor_prefix,
              anchor_suffix: note.anchor_suffix,
              content: note.content
            }
          } : {
            update_note: {
              note_id: note.id,
              content: note.content
            }
          };

          const res = await fetch(`/api/history/analyses/${this.state.currentAnalysisId}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });

          if (!res.ok) {
            console.error('Failed to save note:', await res.text());
            return false;
          }

          const data = await res.json();

          // Update local note with server ID if new
          if (isNew && data.note_id) {
            const noteIndex = this.state.notes.findIndex(n => n._tempId === note._tempId);
            if (noteIndex !== -1) {
              this.state.notes[noteIndex].id = data.note_id;
              delete this.state.notes[noteIndex]._tempId;
              // Update activeNoteId to use the real ID
              this.state.activeNoteId = data.note_id;
              // Update highlight's data attribute
              const highlight = document.querySelector(`.note-highlight[data-note-id="${note._tempId}"]`);
              if (highlight) {
                highlight.dataset.noteId = data.note_id;
              }
            }
          }

          return true;
        } catch (error) {
          console.error('Failed to save note:', error);
          return false;
        }
      },

      /**
       * Delete note from backend via API
       */
      async deleteNoteFromBackend(noteId) {
        if (!this.state.currentAnalysisId) {
          console.warn('Cannot delete note: no analysis ID');
          return false;
        }

        try {
          const res = await fetch(`/api/history/analyses/${this.state.currentAnalysisId}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ delete_note: { note_id: noteId } })
          });

          if (!res.ok) {
            console.error('Failed to delete note:', await res.text());
            return false;
          }

          return true;
        } catch (error) {
          console.error('Failed to delete note:', error);
          return false;
        }
      }
    };

    // Check if config is loaded
    if (typeof CONFIG === 'undefined' || !CONFIG.GEMINI_API_KEY) {
      document.body.innerHTML = `
        <div style="padding: 40px; text-align: center;">
          <h2 style="color: var(--error);">Configuration Error</h2>
          <p>Please create a <code>config-gemini.js</code> file with your Gemini API key.</p>
          <p>See <code>config-gemini.example.js</code> for template.</p>
        </div>
      `;
    } else {
      // Initialize app
      ChatApp.init();
    }
  </script>
</body>
</html>
