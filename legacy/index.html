<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SPD Plan Comparison Agent</title>

  <!-- External Dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script>

  <!-- Modern Tech-Forward Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Space+Grotesk:wght@500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    :root {
      /* Light Modern Monochrome Palette */
      --bg-primary: #ffffff;
      --bg-secondary: #f8f9fa;
      --bg-tertiary: #f1f3f5;
      --surface-glass: rgba(255, 255, 255, 0.8);
      --surface-elevated: rgba(0, 0, 0, 0.02);

      /* Subtle Monochrome Gradients */
      --gradient-primary: linear-gradient(135deg, #1a1a1a 0%, #4a4a4a 100%);
      --gradient-accent: linear-gradient(135deg, #2d2d2d 0%, #5a5a5a 100%);
      --gradient-success: linear-gradient(135deg, #333333 0%, #666666 100%);
      --gradient-border: linear-gradient(135deg, rgba(0, 0, 0, 0.08), rgba(0, 0, 0, 0.12));

      /* Text Colors */
      --text-primary: #1a1a1a;
      --text-secondary: #666666;
      --text-muted: #999999;

      /* Accent Colors - Minimal */
      --accent-dark: #2d2d2d;
      --accent-gray: #5a5a5a;
      --accent-light: #8a8a8a;
      --accent-success: #4a4a4a;

      /* Borders */
      --border-subtle: rgba(0, 0, 0, 0.06);
      --border-medium: rgba(0, 0, 0, 0.12);

      /* Shadows */
      --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.06);
      --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.08);
      --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.12);
      --shadow-glow: 0 0 40px rgba(0, 0, 0, 0.1);

      /* Error */
      --error: #d32f2f;
      --error-bg: rgba(211, 47, 47, 0.08);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      height: 100vh;
      overflow: hidden;
      position: relative;
    }

    /* Subtle animated background pattern */
    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle at 20% 50%, rgba(0, 0, 0, 0.02) 0%, transparent 50%),
                  radial-gradient(circle at 80% 80%, rgba(0, 0, 0, 0.03) 0%, transparent 50%);
      animation: backgroundShift 20s ease infinite;
      pointer-events: none;
      z-index: 0;
    }

    @keyframes backgroundShift {
      0%, 100% { transform: translate(0, 0) rotate(0deg); }
      33% { transform: translate(5%, -5%) rotate(120deg); }
      66% { transform: translate(-5%, 5%) rotate(240deg); }
    }

    .chat-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      max-width: 100%;
      margin: 0 auto;
      padding: 0;
      position: relative;
      z-index: 1;
    }

    /* Modern Header with Asymmetric Design */
    .chat-header {
      padding: 24px 32px;
      border-bottom: 1px solid var(--border-medium);
      background: var(--surface-glass);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: relative;
      box-shadow: var(--shadow-sm);
    }

    .chat-header::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: var(--gradient-border);
    }

    .chat-header h1 {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 28px;
      font-weight: 700;
      color: var(--text-primary);
      letter-spacing: -0.02em;
    }

    .model-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: var(--surface-elevated);
      padding: 8px 16px;
      border-radius: 12px;
      font-size: 13px;
      color: var(--text-secondary);
      font-weight: 500;
      border: 1px solid var(--border-medium);
      box-shadow: var(--shadow-sm);
      position: relative;
      overflow: hidden;
    }

    .model-badge::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--gradient-border);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .model-badge:hover::before {
      opacity: 1;
    }

    .thinking-indicator-badge {
      background: var(--text-primary);
      color: white;
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
      z-index: 1;
    }

    /* Messages Area */
    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 32px;
      scroll-behavior: smooth;
      position: relative;
    }

    /* Custom Scrollbar */
    .messages-container::-webkit-scrollbar {
      width: 8px;
    }

    .messages-container::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }

    .messages-container::-webkit-scrollbar-thumb {
      background: var(--surface-elevated);
      border-radius: 4px;
    }

    .messages-container::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .message {
      margin-bottom: 32px;
      animation: slideInUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
    }

    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(20px) scale(0.98);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .message-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
      font-size: 12px;
      font-weight: 700;
      color: var(--text-secondary);
      font-family: 'JetBrains Mono', monospace;
      text-transform: uppercase;
      letter-spacing: 1.5px;
    }

    .message-role {
      position: relative;
      padding-left: 16px;
    }

    .message-role::before {
      content: '‚óè';
      position: absolute;
      left: 0;
      color: var(--text-primary);
      animation: pulse 2s ease infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .message.user .message-role::before {
      color: var(--text-secondary);
    }

    /* Glass Morphism Message Cards */
    .message-content {
      background: var(--surface-glass);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      padding: 24px;
      border-radius: 16px;
      border: 1px solid var(--border-medium);
      box-shadow: var(--shadow-md);
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .message-content::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: var(--gradient-primary);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .message-content:hover {
      border-color: rgba(0, 0, 0, 0.2);
      box-shadow: var(--shadow-lg);
    }

    .message-content:hover::before {
      opacity: 1;
    }

    .message.user .message-content {
      background: rgba(0, 0, 0, 0.02);
      border-color: rgba(0, 0, 0, 0.15);
    }

    .message.user .message-content::before {
      background: var(--gradient-success);
    }

    /* Thinking Block with Tech Aesthetic */
    .thinking-block {
      background: rgba(0, 0, 0, 0.02);
      border-left: 3px solid var(--text-primary);
      padding: 16px 20px;
      margin: 16px 0;
      border-radius: 12px;
      font-family: 'JetBrains Mono', Monaco, monospace;
      font-size: 13px;
      color: var(--text-secondary);
      position: relative;
      border: 1px solid var(--border-medium);
      box-shadow: var(--shadow-sm);
    }

    .thinking-block::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg,
        transparent 0%,
        rgba(0, 0, 0, 0.01) 50%,
        transparent 100%);
      pointer-events: none;
    }

    .thinking-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      font-weight: 700;
      color: var(--text-primary);
      cursor: pointer;
      user-select: none;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 11px;
      transition: all 0.2s ease;
    }

    .thinking-header:hover {
      color: var(--text-secondary);
    }

    .thinking-toggle {
      font-size: 11px;
      color: var(--text-secondary);
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 6px;
      border: 1px solid var(--border-medium);
      transition: all 0.2s ease;
    }

    .thinking-toggle:hover {
      background: rgba(0, 0, 0, 0.08);
      color: var(--text-primary);
    }

    .thinking-content {
      white-space: pre-wrap;
      word-wrap: break-word;
      text-align: left;
      line-height: 1.7;
      color: var(--text-secondary);
    }

    .thinking-content.collapsed {
      display: none;
    }

    /* Response Text Styling */
    .response-text {
      line-height: 1.8;
      color: var(--text-primary);
    }

    .response-text p {
      margin-bottom: 16px;
    }

    .response-text p:last-child {
      margin-bottom: 0;
    }

    .response-text code {
      background: rgba(0, 0, 0, 0.05);
      color: var(--text-primary);
      padding: 3px 8px;
      border-radius: 6px;
      font-size: 13px;
      font-family: 'JetBrains Mono', Monaco, monospace;
      border: 1px solid var(--border-medium);
    }

    .response-text pre {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 12px;
      overflow-x: auto;
      margin: 16px 0;
      border: 1px solid var(--border-medium);
      box-shadow: var(--shadow-sm);
    }

    .response-text pre code {
      background: none;
      padding: 0;
      border: none;
      color: var(--text-secondary);
    }

    .response-text ul, .response-text ol {
      margin-left: 24px;
      margin-bottom: 16px;
    }

    .response-text li {
      margin-bottom: 8px;
    }

    .response-text blockquote {
      border-left: 3px solid var(--text-primary);
      padding-left: 16px;
      margin: 16px 0;
      color: var(--text-secondary);
      background: rgba(0, 0, 0, 0.03);
      padding: 12px 12px 12px 16px;
      border-radius: 8px;
    }

    .response-text h1, .response-text h2, .response-text h3 {
      font-family: 'Space Grotesk', sans-serif;
      font-weight: 700;
      margin-top: 24px;
      margin-bottom: 12px;
      color: var(--text-primary);
    }

    .response-text a {
      color: var(--text-primary);
      text-decoration: none;
      border-bottom: 2px solid var(--text-primary);
      transition: all 0.2s ease;
      font-weight: 600;
    }

    .response-text a:hover {
      color: var(--text-secondary);
      border-bottom-color: var(--text-secondary);
    }

    /* Streaming Indicator */
    .streaming-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin-top: 12px;
    }

    .streaming-indicator .dot {
      width: 8px;
      height: 8px;
      background: var(--text-primary);
      border-radius: 50%;
      animation: dotPulse 1.4s ease-in-out infinite;
    }

    .streaming-indicator .dot:nth-child(2) {
      animation-delay: 0.2s;
    }

    .streaming-indicator .dot:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes dotPulse {
      0%, 100% {
        opacity: 0.3;
        transform: scale(0.8);
      }
      50% {
        opacity: 1;
        transform: scale(1.2);
      }
    }

    /* Modern Input Area */
    .input-container {
      border-top: 1px solid var(--border-medium);
      padding: 24px 32px;
      background: var(--surface-glass);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      position: relative;
      box-shadow: 0 -4px 16px rgba(0, 0, 0, 0.2);
    }

    .input-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: var(--gradient-border);
    }

    .input-form {
      display: flex;
      gap: 16px;
      align-items: flex-end;
    }

    #user-input {
      flex: 1;
      min-height: 56px;
      max-height: 200px;
      padding: 16px 20px;
      border: 2px solid var(--border-medium);
      border-radius: 12px;
      font-size: 15px;
      font-family: 'Inter', sans-serif;
      background: var(--bg-secondary);
      color: var(--text-primary);
      resize: none;
      outline: none;
      transition: all 0.3s ease;
      box-shadow: var(--shadow-sm);
    }

    #user-input::placeholder {
      color: var(--text-muted);
    }

    #user-input:focus {
      border-color: var(--text-primary);
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05), var(--shadow-md);
      background: var(--bg-tertiary);
    }

    /* Monochrome Button with Animation */
    #send-button {
      padding: 16px 32px;
      background: var(--text-primary);
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 15px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 100px;
      font-family: 'Space Grotesk', sans-serif;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: var(--shadow-md);
      position: relative;
      overflow: hidden;
    }

    #send-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s ease;
    }

    #send-button:hover:not(:disabled)::before {
      left: 100%;
    }

    #send-button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
      background: var(--text-secondary);
    }

    #send-button:active:not(:disabled) {
      transform: translateY(0);
    }

    #send-button:disabled {
      background: var(--surface-elevated);
      color: var(--text-muted);
      cursor: not-allowed;
      box-shadow: none;
      border: 1px solid var(--border-medium);
    }

    /* Error Styling */
    .error-message {
      background: var(--error-bg);
      border: 1px solid var(--error);
      color: var(--error);
      padding: 16px 20px;
      border-radius: 12px;
      margin: 16px 0;
      font-size: 14px;
      font-family: 'JetBrains Mono', monospace;
      box-shadow: 0 4px 16px rgba(255, 107, 107, 0.2);
    }

    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 80px 32px;
      color: var(--text-secondary);
    }

    .empty-state h2 {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 32px;
      margin-bottom: 16px;
      color: var(--text-primary);
      font-weight: 700;
    }

    .empty-state p {
      font-size: 16px;
      color: var(--text-muted);
    }

    /* Plan Docs File Upload Section - Modern Design */
    .files-section {
      border-bottom: 1px solid var(--border-medium);
      background: var(--surface-glass);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      position: relative;
    }

    .files-section::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: var(--gradient-border);
    }

    .files-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 32px;
      cursor: pointer;
      user-select: none;
      transition: all 0.3s ease;
    }

    .files-header:hover {
      background: rgba(0, 0, 0, 0.02);
    }

    .files-title {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 15px;
      font-weight: 700;
      color: var(--text-primary);
      font-family: 'Space Grotesk', sans-serif;
      letter-spacing: 0.5px;
    }

    .files-icon {
      font-size: 20px;
    }

    .files-count {
      font-size: 13px;
      color: var(--text-muted);
      font-weight: 500;
      font-family: 'JetBrains Mono', monospace;
    }

    .files-toggle {
      font-size: 14px;
      color: var(--text-secondary);
      transition: transform 0.3s ease;
    }

    .files-toggle.collapsed {
      transform: rotate(-90deg);
    }

    .files-content {
      padding: 24px 32px 28px;
      max-height: 500px;
      overflow-y: auto;
      transition: max-height 0.3s ease-out, padding 0.3s ease-out;
    }

    .files-content::-webkit-scrollbar {
      width: 6px;
    }

    .files-content::-webkit-scrollbar-track {
      background: transparent;
    }

    .files-content::-webkit-scrollbar-thumb {
      background: var(--surface-elevated);
      border-radius: 3px;
    }

    .files-content.collapsed {
      max-height: 0;
      padding: 0 32px;
      overflow: hidden;
    }

    /* Modern Drop Zone */
    .drop-zone {
      border: 2px dashed var(--border-medium);
      border-radius: 16px;
      padding: 48px 32px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-bottom: 20px;
      background: var(--bg-secondary);
      position: relative;
      overflow: hidden;
    }

    .drop-zone::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--gradient-border);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .drop-zone:hover {
      border-color: var(--text-primary);
      background: var(--bg-tertiary);
      box-shadow: var(--shadow-md);
    }

    .drop-zone:hover::before {
      opacity: 0.05;
    }

    .drop-zone.dragging {
      border-color: var(--text-primary);
      background: rgba(0, 0, 0, 0.04);
      border-width: 3px;
      box-shadow: var(--shadow-glow);
    }

    .drop-zone-icon {
      font-size: 48px;
      margin-bottom: 12px;
      opacity: 0.7;
    }

    .drop-zone-text {
      font-size: 16px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 8px;
      font-family: 'Space Grotesk', sans-serif;
    }

    .drop-zone-hint {
      font-size: 13px;
      color: var(--text-muted);
      line-height: 1.6;
      font-family: 'JetBrains Mono', monospace;
    }

    .files-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* Modern File Cards */
    .file-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border-medium);
      border-radius: 12px;
      padding: 16px 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      transition: all 0.3s ease;
      animation: slideInUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      position: relative;
      overflow: hidden;
    }

    .file-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 3px;
      height: 100%;
      background: var(--gradient-primary);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .file-card:hover {
      border-color: var(--text-primary);
      box-shadow: var(--shadow-md);
      transform: translateX(4px);
    }

    .file-card:hover::before {
      opacity: 1;
    }

    .file-card.uploading {
      opacity: 0.7;
      animation: pulse 2s ease infinite;
    }

    .file-card.error {
      border-color: var(--error);
      background: var(--error-bg);
    }

    .file-card.error::before {
      background: var(--error);
      opacity: 1;
    }

    .file-icon {
      font-size: 28px;
      flex-shrink: 0;
    }

    .file-info {
      flex: 1;
      min-width: 0;
    }

    .file-name {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
      word-break: break-all;
      line-height: 1.5;
    }

    .file-meta {
      font-size: 12px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      font-family: 'JetBrains Mono', monospace;
    }

    .file-size {
      display: inline-flex;
      align-items: center;
    }

    .file-status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 600;
    }

    .file-status.uploaded {
      color: var(--text-primary);
    }

    .file-status.uploading {
      color: var(--text-secondary);
    }

    .file-status.error {
      color: var(--error);
    }

    .file-remove {
      flex-shrink: 0;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      border: 1px solid var(--border-medium);
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: all 0.3s ease;
    }

    .file-remove:hover {
      background: var(--error);
      color: white;
      border-color: var(--error);
      transform: scale(1.1);
      box-shadow: var(--shadow-md);
    }

    /* Initial Compare Button UI - Hero Style */
    .initial-prompt {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
    }

    .compare-button {
      width: 100%;
      max-width: 500px;
      padding: 20px 48px;
      background: var(--text-primary);
      color: white;
      border: none;
      border-radius: 16px;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      font-family: 'Space Grotesk', sans-serif;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: var(--shadow-lg);
      position: relative;
      overflow: hidden;
    }

    .compare-button::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      transform: translate(-50%, -50%);
      transition: width 0.6s ease, height 0.6s ease;
    }

    .compare-button:hover:not(:disabled)::before {
      width: 300px;
      height: 300px;
    }

    .compare-button:hover:not(:disabled) {
      transform: translateY(-4px) scale(1.02);
      box-shadow: var(--shadow-lg);
      background: var(--text-secondary);
    }

    .compare-button:active:not(:disabled) {
      transform: translateY(-2px) scale(1);
    }

    .compare-button:disabled {
      background: var(--surface-elevated);
      color: var(--text-muted);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
      border: 1px solid var(--border-medium);
    }

    .compare-button.comparing {
      background: var(--text-secondary);
      animation: pulse 2s ease infinite;
    }

    .helper-text {
      font-size: 14px;
      color: var(--text-secondary);
      text-align: center;
      margin: 0;
      font-family: 'JetBrains Mono', monospace;
    }

    .helper-text.warning {
      color: var(--text-primary);
      font-weight: 600;
    }

    /* Responsive Design - Mobile & Tablet */
    @media (max-width: 768px) {
      .chat-header {
        padding: 20px 24px;
      }

      .chat-header h1 {
        font-size: 22px;
      }

      .model-badge {
        padding: 6px 12px;
        font-size: 12px;
      }

      .thinking-indicator-badge {
        font-size: 10px;
        padding: 5px 10px;
      }

      .files-header {
        padding: 14px 24px;
      }

      .files-content {
        padding: 20px 24px 24px;
      }

      .drop-zone {
        padding: 36px 24px;
      }

      .drop-zone-icon {
        font-size: 40px;
      }

      .drop-zone-text {
        font-size: 15px;
      }

      .drop-zone-hint {
        font-size: 12px;
      }

      .file-card {
        padding: 14px 16px;
        gap: 12px;
      }

      .file-icon {
        font-size: 24px;
      }

      .file-name {
        font-size: 13px;
      }

      .file-meta {
        font-size: 11px;
      }

      .messages-container {
        padding: 24px 20px;
      }

      .message-content {
        padding: 20px;
      }

      .input-container {
        padding: 20px 24px;
      }

      #user-input {
        min-height: 52px;
        padding: 14px 18px;
        font-size: 14px;
      }

      #send-button {
        padding: 14px 28px;
        font-size: 14px;
        min-width: 90px;
      }

      .compare-button {
        max-width: 100%;
        padding: 18px 40px;
        font-size: 16px;
      }

      .empty-state {
        padding: 60px 24px;
      }

      .empty-state h2 {
        font-size: 26px;
      }

      .empty-state p {
        font-size: 15px;
      }
    }

    @media (max-width: 480px) {
      .chat-header {
        padding: 16px 20px;
      }

      .chat-header h1 {
        font-size: 18px;
      }

      .model-badge {
        padding: 5px 10px;
        font-size: 11px;
      }

      .files-header {
        padding: 12px 20px;
      }

      .files-content {
        padding: 16px 20px 20px;
      }

      .messages-container {
        padding: 20px 16px;
      }

      .message-content {
        padding: 16px;
      }

      .input-container {
        padding: 16px 20px;
      }

      #user-input {
        padding: 12px 16px;
        font-size: 14px;
      }

      #send-button {
        padding: 12px 24px;
        font-size: 13px;
        min-width: 80px;
      }

      .compare-button {
        padding: 16px 32px;
        font-size: 15px;
      }
    }
  </style>
</head>
<body>
  <div class="chat-container">
    <header class="chat-header">
      <h1>SPD Plan Comparison Agent</h1>
      <div class="model-badge">
        <span class="thinking-indicator-badge">Extended Thinking</span>
      </div>
    </header>

    <!-- Plan Docs File Upload Section -->
    <section class="files-section" id="files-section">
      <div class="files-header" onclick="ChatApp.toggleFilesPanel()">
        <div class="files-title">
          <span class="files-icon">üìÅ</span>
          <span>Plan Docs</span>
          <span class="files-count" id="files-count">(0 files)</span>
        </div>
        <span class="files-toggle" id="files-toggle">‚ñº</span>
      </div>

      <div class="files-content" id="files-content">
        <div class="drop-zone" id="drop-zone">
          <input type="file" id="file-input" multiple accept=".pdf,.txt,.docx,.doc,.csv,.xlsx,.xls,image/*" hidden>
          <div class="drop-zone-content">
            <div class="drop-zone-icon">üìÑ</div>
            <div class="drop-zone-text">Drop files here or click to browse</div>
            <div class="drop-zone-hint">Supports PDF, DOCX, TXT, CSV, Excel, and images ‚Ä¢ Max 32 MB per file</div>
          </div>
        </div>

        <div class="files-list" id="files-list">
          <!-- File cards will be dynamically added here -->
        </div>
      </div>
    </section>

    <div class="messages-container" id="messages">
      <div class="empty-state">
        <h2>Ready to compare plan documents</h2>
        <p>Upload your PDF files above and click "Compare Documents" to begin analysis.</p>
      </div>
    </div>

    <div class="input-container">
      <form class="input-form" id="chat-form">
        <textarea
          id="user-input"
          placeholder="Ask anything..."
          rows="1"
          autofocus
        ></textarea>
        <button type="submit" id="send-button">Send</button>
      </form>
    </div>
  </div>

  <!-- Load config before app script -->
  <script src="config.js"></script>

  <script>
    // Configure marked for markdown rendering
    marked.setOptions({
      breaks: true,
      gfm: true,
      headerIds: false,
      highlight: function(code, lang) {
        if (Prism.languages[lang]) {
          return Prism.highlight(code, Prism.languages[lang], lang);
        }
        return code;
      }
    });

    // System Prompt with Prompt Caching
    const SYSTEM_PROMPT = [
      {
        type: "text",
        text: `You are a specialized pension plan document analyst with deep expertise in ERISA-regulated multiemployer pension plans, particularly those affiliated with UNITE-HERE and other hospitality industry unions. Your primary function is to extract, compare, and analyze claims and appeals procedures across multiple plan units from PDF documents provided in context.
CORE COMPETENCIES
<expertise>
- ERISA pension plan regulations and compliance requirements
- Multiemployer pension fund structures and governance
- Claims and appeals procedures under DOL regulations (29 CFR 2560)
- Qualified Domestic Relations Orders (QDROs)
- Summary Plan Descriptions (SPDs) and Summary of Material Modifications (SMMs)
- Pension benefit calculation methodologies
- Arbitration and dispute resolution procedures in pension contexts
- Comparative regulatory analysis across jurisdictions
</expertise>
<analytical_approach>
You approach document analysis systematically:

Think step-by-step through complex comparisons before responding
Acknowledge uncertainty when information is missing or ambiguous rather than making assumptions
Flag variability in terminology and structure across documents explicitly
Prioritize critical differences that materially affect participant rights
Maintain precision in extracting dates, timeframes, and procedural requirements
Preserve context when comparing similar-but-different provisions
</analytical_approach>

DOCUMENT HANDLING PROTOCOLS
<document_structure_assumptions>
The documents you receive will be PDF pension plan materials with potentially HIGH variability:
Expected document types:

Summary Plan Descriptions (SPDs)
Summary of Material Modifications (SMMs)
Plan Documents (formal legal text)
Trustee notices and announcements
Benefit calculation guides

Expected variability:

Terminology: Different plans may use different terms for identical concepts (e.g., "plan units" vs. "local plans" vs. "participating employers")
Organization: Some SPDs have indexed sections; others are narrative; some mix both
Completeness: Some documents may be excerpts or appendices rather than complete SPDs
Effective dates: Documents may reflect different amendment histories
Format quality: PDFs may be scanned images, text-native, or mixed

You must adapt dynamically to the structure and quality of each document provided.
</document_structure_assumptions>
<extraction_methodology>
When extracting claims and appeals information, use this systematic approach:

Identify the plan unit first:

Look for plan name, EIN, geographic jurisdiction, union local number
Note contributing employer associations
Flag if plan identity is unclear or if document covers multiple plans


Locate claims/appeals sections using multiple search strategies:

Table of contents references (if available)
Section headers containing: "claims", "appeals", "benefits application", "dispute resolution", "review procedure", "denial"
ERISA rights statements (required section often near end)
Search for regulatory citations: "29 CFR", "ERISA Section 503"


Extract complete procedural elements systematically:
<required_data_points>
INITIAL CLAIMS PROCEDURES:

Who may file a claim (participant, beneficiary, authorized representative)
How to file (forms, methods: mail/email/online portal)
Where to file (plan office address, online submission)
Required documentation with claim
Filing deadlines or time limits (if any)
Plan's decision timeframe (typically 90 days for pension, 45 days for disability)
Extension provisions (additional time allowed, notification requirements)
Deemed denied if no timely response (yes/no)
Content requirements for denial notices

APPEALS PROCEDURES:

Appeal filing deadline (typically 60 or 180 days after denial)
Required form/format for appeals
Who reviews appeals (full board, committee, independent fiduciary)
Claimant rights during appeal (document review, representation, hearing)
Decision timeframe for appeals
Extension provisions for appeals
Required content of appeal decision
Finality of decision (binding/non-binding language)

POST-APPEAL PROCEDURES:

Mandatory arbitration (yes/no/voluntary)
Arbitration rules/forum (AAA, JAMS, other)
Cost allocation for arbitration
Class action waiver (yes/no)
Lawsuit filing deadline (statute of limitations)
Exhaustion requirements before litigation

SPECIAL PROVISIONS:

COVID-19 or other emergency tolling rules
Enhanced requirements for disability claims
Special expedited procedures (if any)
Language access provisions
Representation rights
</required_data_points>


Handle missing information gracefully:

Explicitly state "Not specified in documents provided" rather than inferring
Note if information may exist elsewhere (e.g., "May be in master plan document")
Flag if omission is unusual or potentially non-compliant
Distinguish between "not mentioned" vs. "explicitly states not required"
</extraction_methodology>



OUTPUT REQUIREMENTS
<structured_output_format>
Unless otherwise instructed, produce your analysis using this XML-based structure:
xml<plan_analysis>
  <plan_unit id="[IDENTIFIER]" name="[FULL PLAN NAME]">
    <metadata>
      <ein>[Employer ID]</ein>
      <plan_number>[Plan Number]</plan_number>
      <documents_reviewed>
        <document type="SPD" effective_date="[DATE]" filename="[NAME]"/>
        <document type="SMM" effective_date="[DATE]" filename="[NAME]"/>
      </documents_reviewed>
      <completeness_assessment>[COMPLETE|PARTIAL|UNCLEAR]</completeness_assessment>
      <notes>[Any relevant context about documents]</notes>
    </metadata>

    <initial_claims>
      <decision_timeframe>[X days]</decision_timeframe>
      <extension_possible>[YES|NO] - [details]</extension_possible>
      <deemed_denied_if_no_response>[YES|NO]</deemed_denied_if_no_response>
      <filing_requirements>[Description]</filing_requirements>
      <required_documents>[List]</required_documents>
      <denial_notice_requirements>[Description]</denial_notice_requirements>
      <notes>[Any nuances, exceptions, or clarifications]</notes>
    </initial_claims>

    <appeals_procedure>
      <filing_deadline>[X days after denial]</filing_deadline>
      <late_filing_consideration>[YES|NO|NOT SPECIFIED]</late_filing_consideration>
      <review_body>[Trustees|Committee|Other]</review_body>
      <claimant_rights>[Description of rights during appeal]</claimant_rights>
      <decision_timeframe>[Details]</decision_timeframe>
      <decision_finality>[BINDING|NOT SPECIFIED]</decision_finality>
      <notes>[Any nuances, exceptions, or clarifications]</notes>
    </appeals_procedure>

    <post_appeal>
      <mandatory_arbitration>[YES|NO|VOLUNTARY]</mandatory_arbitration>
      <arbitration_details>[Forum, rules, cost allocation if applicable]</arbitration_details>
      <class_action_waiver>[YES|NO|NOT SPECIFIED]</class_action_waiver>
      <lawsuit_deadline>[Timeframe if specified]</lawsuit_deadline>
      <notes>[Any nuances, exceptions, or clarifications]</notes>
    </post_appeal>

    <special_provisions>
      <!-- Any COVID, disability-specific, or other special rules -->
    </special_provisions>
  </plan_unit>
</plan_analysis>
Comparative analysis format:
When comparing across multiple plan units, structure output as:
xml<comparative_analysis>
  <summary>
    <plan_units_analyzed>[Number]</plan_units_analyzed>
    <complete_documentation>[List of units with complete docs]</complete_documentation>
    <incomplete_documentation>[List of units with gaps]</incomplete_documentation>
    <critical_findings>[3-5 bullet points of most important variations]</critical_findings>
  </summary>

  <detailed_comparison>
    <dimension name="[e.g., Initial Claims Timeframe]">
      <variation_analysis>[Description of how plans differ]</variation_analysis>
      <plan_specifics>
        <plan id="[ID]">[Specific provision]</plan>
        <!-- Repeat for each plan -->
      </plan_specifics>
      <impact_assessment severity="[HIGH|MEDIUM|LOW]">
        [What this variation means for participants]
      </impact_assessment>
    </dimension>
    <!-- Repeat for each key dimension -->
  </detailed_comparison>

  <risk_and_compliance_assessment>
    <potential_legal_risks>[Identified issues]</potential_legal_risks>
    <participant_protection_ranking>[Which plans are most/least favorable]</participant_protection_ranking>
    <standardization_opportunities>[Where alignment would benefit participants]</standardization_opportunities>
  </risk_and_compliance_assessment>

  <recommendations priority="[HIGH|MEDIUM|LOW]">
    <!-- Actionable recommendations -->
  </recommendations>
</comparative_analysis>
</structured_output_format>
<response_style_guidelines>
Be direct and precise:

Lead with findings, not process descriptions
Use specific numbers and dates, not vague language ("60 days" not "short period")
State facts without hedging unless genuinely uncertain

Flag critical items clearly:

Use "‚ö†Ô∏è CRITICAL:" prefix for provisions that substantially restrict participant rights
Use "‚úì FAVORABLE:" prefix for unusually participant-friendly provisions
Use "‚ùì UNCLEAR:" prefix when documentation is ambiguous

Maintain professional tone:

Analytical and neutral, not advocacy or judgmental
Acknowledge legitimate policy trade-offs
Note when variations may reflect different plan demographics or funding situations

Handle ambiguity transparently:

Explicitly state when information is "Not specified in documents provided"
Distinguish between "unclear from document" vs. "plan is silent on this"
Suggest what additional documents would clarify uncertainties

Prioritize actionability:

Emphasize differences that affect participant rights or plan compliance
De-emphasize immaterial formatting or organizational differences
Always provide "so what" analysis - why a difference matters
</response_style_guidelines>

THINKING APPROACH FOR COMPLEX ANALYSIS
<extended_thinking_guidance>
For complex comparative analysis tasks involving multiple documents and cross-plan comparisons:
Use extended thinking by starting your analysis with: "Let me think through this systematically" or "I'll analyze this step-by-step"
Structure your thinking process as:
<thinking_structure>

Document inventory and quality assessment

What documents do I have for each plan?
Are they complete SPDs or partial documents (SMMs, appendices)?
What are the effective dates?
Quality of OCR/text extraction if scanned PDFs


Terminology mapping

Are there different terms used for the same concepts across plans?
Build a translation key (e.g., "Plan Unit" = "Local" = "Participating Employer Group")


Systematic extraction by plan

Extract each data point for Plan A
Extract each data point for Plan B
[Repeat]
Note gaps or ambiguities for each


Cross-plan comparison

Which elements are identical across plans?
Which elements vary, and by how much?
Which variations are material vs. immaterial?


Criticality assessment

Which differences substantially affect participant access to benefits?
Which differences create legal/compliance risks?
Which differences are merely administrative/stylistic?


Pattern identification

Are certain plans consistently more restrictive or protective?
Do plans cluster into groups with similar approaches?
Do effective dates correlate with procedural variations?


Output synthesis

Structure findings for maximum clarity and actionability
Prioritize most important discoveries
Prepare recommendations grounded in findings
</thinking_structure>



When to use deeper thinking (think harder/ultrathink):

Complex multi-plan comparisons (5+ plans)
Ambiguous or conflicting language in documents
Identifying subtle procedural differences with major implications
Building comprehensive recommendations
Assessing legal compliance across multiple jurisdictions
</extended_thinking_guidance>

HANDLING EDGE CASES AND CHALLENGES
<common_challenges>
Challenge: Incomplete documentation
Response: Clearly flag missing information. State "Complete SPD not provided - analysis based on [SMM dated X] only. Key sections that may exist in full SPD but are not available: [list]."
Challenge: Conflicting information within same plan
Response: Flag the conflict explicitly: "‚ö†Ô∏è INTERNAL CONFLICT: Page X states [A] but Page Y states [B]. Likely explanation: [hypothesis]. Recommend verification with plan administrator."
Challenge: Highly technical legal language
Response: Extract the procedural requirements accurately, then provide plain-language explanation in notes field. Do not oversimplify at the expense of accuracy.
Challenge: Documents from different time periods
Response: Note effective dates prominently. If comparing plans with different amendment histories, flag: "Comparison may reflect temporal differences - Plan A document effective 2016, Plan B effective 2020."
Challenge: Non-standard terminology
Response: Use the plan's own terminology in extraction, but provide translation/mapping in notes: "Plan uses term 'Contribution Unit' - appears equivalent to 'Plan Unit' used by other plans."
Challenge: Scanned PDFs with poor OCR
Response: Note text quality issues: "Document is scanned image with OCR errors. [X] may actually be [Y] - recommend verification. Some sections illegible."
Challenge: User asks for comparison when documentation is inadequate
Response: "I can provide preliminary comparison based on available documents, but [Plan X] has incomplete documentation. Findings for Plan X should be considered provisional pending receipt of complete SPD. Specifically missing: [list]."
</common_challenges>
CRITICAL REMINDERS
<do_not_do>
‚ùå Never fabricate information not present in documents
‚ùå Never assume two plans are identical because they're in the same union family
‚ùå Never provide legal advice or definitive compliance opinions
‚ùå Never ignore participant-protective provisions even if unusual
‚ùå Never recommend reducing participant protections without explicit justification
‚ùå Never conflate "not mentioned" with "prohibited" or "not provided"
</do_not_do>
<always_do>
‚úì Always cite specific page numbers or section references when available
‚úì Always flag when you're uncertain rather than guessing
‚úì Always note when a provision is unusually favorable OR unusually restrictive
‚úì Always consider the participant perspective, not just administrative efficiency
‚úì Always distinguish between federal law requirements and plan-specific choices
‚úì Always update your analysis if provided additional or corrected information
</always_do>
EXAMPLES OF EXCELLENT ANALYSIS
<example_1_simple_extraction>
User prompt: "Extract the appeals filing deadline for the San Diego plan."
Excellent response:
"Based on the San Diego Unite-Here Pension Plan SPD (effective December 1, 2020):
Appeals filing deadline: 60 days after receipt of written denial notice
Additional context from document (Page 32, Section 16):

Trustees may consider late applications if delay was for 'reasonable cause'
Appeal must state 'clear and concise reasons for disagreement'
Appeal reviewed by Board of Trustees or delegated subcommittee

Source: SD_SPD_2021-01-26_FINAL.pdf, pages 31-32"
</example_1_simple_extraction>
<example_2_handling_ambiguity>
User prompt: "Does the Las Vegas plan require exhaustion of appeals before filing a lawsuit?"
Excellent response:
"Cannot be definitively determined from documents provided.
Documents reviewed:

LV-SMM_COVID-19_Assistance_for_2020_English.pdf (SMM only, not full SPD)
LV-Summary_of_Material_Modification_Disability_Rules_E.pdf (SMM only)
LV-SMMPensionBenefitIncrease2_17_17_E.pdf (SMM only)

Findings:
The SMMs provided do not contain the complete claims and appeals procedures. The Disability Rules SMM (dated April 2, 2018) specifies:

180-day appeal deadline after denial
Enhanced disclosure requirements for disability claims

However, SMMs typically supplement rather than replace the full SPD. The complete appeals procedure, including exhaustion requirements and lawsuit deadlines, would be in the master SPD.
Recommendation: Obtain the current comprehensive SPD for Las Vegas plan to determine:

Whether exhaustion of appeals is required before litigation
Any statute of limitations for filing suit
Complete procedural requirements

Note: ERISA generally requires exhaustion of plan remedies before filing suit, but plan-specific language should be reviewed."
</example_2_handling_ambiguity>
<example_3_critical_finding>
User prompt: "Compare arbitration requirements across all plans."
Excellent response:
"‚ö†Ô∏è CRITICAL VARIATION IDENTIFIED
Three distinct approaches to arbitration across the plan units:
MANDATORY ARBITRATION:

San Diego Plan: YES

Binding arbitration per AAA labor arbitration rules is EXCLUSIVE remedy
Applies to ALL claims including fiduciary breach
Each party bears equal cost
Explicitly prohibits class arbitration
Source: SD_SPD_2021-01-26_FINAL.pdf, page 33



VOLUNTARY ARBITRATION:

Sacramento (SIHRTE) Plan: NO mandatory arbitration

States explicitly: "arbitration is voluntary only"
"Parties may mutually agree but not mandatory"
Preserves participant's right to jury trial
Source: W300_SIHRTE_Pension_SPD_090116_Final_ENGLISH.pdf, page 22



NOT SPECIFIED:

Las Vegas Plan: Unknown

SMMs provided do not address arbitration
Full SPD needed to determine approach



IMPACT ASSESSMENT:
Severity: HIGH
This represents a fundamental difference in participant access to justice:

San Diego participants have NO choice but arbitration, NO class action rights
Sacramento participants retain full litigation rights including jury trial
Cost implications: Even with 50/50 split, arbitration may be prohibitive for smaller claims

POTENTIAL LEGAL RISK:
Recent case law (particularly Viking River Cruises v. Moriana and circuit court decisions) suggests mandatory arbitration waivers in ERISA plans may face challenges. San Diego's broad arbitration clause covering "all claims" including fiduciary breach may be vulnerable to legal challenge.
RECOMMENDATION:
High priority: Legal review of San Diego's mandatory arbitration provisions by ERISA counsel for compliance with current case law."
</example_3_critical_finding>
FINAL INSTRUCTIONS
When you receive pension plan documents:

First, quickly inventory what documents you have (plan names, types, dates)
Think step-by-step through your extraction and comparison process
Extract systematically using the required data points structure
Flag uncertainties explicitly rather than making assumptions
Prioritize critical findings - what matters most for participants?
Structure output using XML format unless user requests otherwise
Cite sources with document names and page numbers when possible
Provide actionable analysis - don't just describe, interpret significance

Remember: Your analysis directly affects plan participants' ability to access their hard-earned retirement benefits. Precision, thoroughness, and intellectual honesty are paramount. When in doubt, acknowledge uncertainty and recommend additional verification.
You are ready to analyze pension plan documents. Await document provision and specific user instructions.`,
        cache_control: { type: "ephemeral" }
      }
    ];

    // Chat Application
    const ChatApp = {
      state: {
        messages: [],
        isStreaming: false,
        currentThinking: '',
        currentResponse: '',
        currentSignature: '',
        currentBlockType: null,
        abortController: null,
        uploadedFiles: [],
        filesPanelExpanded: true
      },

      init() {
        this.renderInputArea();
        this.initFileUpload();
      },

      isInitialState() {
        return this.state.messages.length === 0;
      },

      renderInputArea() {
        const inputContainer = document.querySelector('.input-container');

        if (this.isInitialState()) {
          const hasFiles = this.state.uploadedFiles.filter(f => f.status === 'uploaded').length > 0;
          const isUploading = this.state.uploadedFiles.some(f => f.status === 'uploading');

          let helperText, helperClass, buttonDisabled;

          if (isUploading) {
            helperText = 'Waiting for files to finish uploading...';
            helperClass = 'warning';
            buttonDisabled = true;
          } else if (!hasFiles) {
            helperText = 'Upload plan documents above to begin comparison';
            helperClass = '';
            buttonDisabled = true;
          } else {
            helperText = 'Click to compare uploaded plan documents';
            helperClass = '';
            buttonDisabled = false;
          }

          inputContainer.innerHTML = `
            <div class="initial-prompt">
              <button
                type="button"
                id="compare-button"
                class="compare-button"
                ${buttonDisabled ? 'disabled' : ''}
              >
                Compare Documents
              </button>
              <p class="helper-text ${helperClass}" id="compare-helper">
                ${helperText}
              </p>
            </div>
          `;

          this.attachCompareButtonHandler();
        } else {
          // Normal chat input
          inputContainer.innerHTML = `
            <form class="input-form" id="chat-form">
              <textarea
                id="user-input"
                placeholder="Ask anything..."
                rows="1"
                autofocus
              ></textarea>
              <button type="submit" id="send-button">Send</button>
            </form>
          `;

          this.setupEventListeners();
          this.autoResizeTextarea();
        }
      },

      attachCompareButtonHandler() {
        const compareButton = document.getElementById('compare-button');
        if (compareButton) {
          compareButton.addEventListener('click', () => {
            if (!this.state.isStreaming && !compareButton.disabled) {
              this.sendMessage('Compare the attached plan documents.');
            }
          });
        }
      },

      setupEventListeners() {
        const form = document.getElementById('chat-form');
        const input = document.getElementById('user-input');

        form.addEventListener('submit', (e) => {
          e.preventDefault();
          const message = input.value.trim();
          if (message && !this.state.isStreaming) {
            this.sendMessage(message);
            input.value = '';
            input.style.height = 'auto';
          }
        });

        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            form.dispatchEvent(new Event('submit'));
          }
        });

        input.addEventListener('input', () => {
          input.style.height = 'auto';
          input.style.height = Math.min(input.scrollHeight, 200) + 'px';
        });
      },

      autoResizeTextarea() {
        const input = document.getElementById('user-input');
        input.style.height = 'auto';
        input.style.height = input.scrollHeight + 'px';
      },

      addMessage(role, content, thinking = '', signature = '') {
        this.state.messages.push({
          role,
          content: Array.isArray(content) ? content : [{ type: 'text', text: content }],
          thinking,
          signature
        });
        this.render();
      },

      async sendMessage(userMessage) {
        // Check if any files are still uploading
        const uploadingFiles = this.state.uploadedFiles.filter(f => f.status === 'uploading');
        if (uploadingFiles.length > 0) {
          alert('Please wait for all files to finish uploading before sending a message.');
          return;
        }

        // Track if this was the initial state
        const wasInitialState = this.isInitialState();

        // Clear empty state
        const messagesContainer = document.getElementById('messages');
        const emptyState = messagesContainer.querySelector('.empty-state');
        if (emptyState) {
          emptyState.remove();
        }

        // Add user message
        this.addMessage('user', userMessage);

        // Transition UI if this was the first message
        if (wasInitialState) {
          this.renderInputArea();
        }

        // Prepare messages for API
        const apiMessages = this.state.messages.map(msg => {
          if (msg.role === 'user') {
            // Build content array with files + text
            const content = [];

            // Add all uploaded files as document blocks (only for successfully uploaded files)
            const uploadedFiles = this.state.uploadedFiles.filter(f => f.status === 'uploaded');
            uploadedFiles.forEach(file => {
              content.push({
                type: 'document',
                source: {
                  type: 'base64',
                  media_type: file.mimeType,
                  data: file.base64Data
                },
                title: file.filename,
                citations: { enabled: true }
              });
            });

            // Add user text
            content.push({
              type: 'text',
              text: msg.content[0].text
            });

            return { role: 'user', content };
          } else {
            // For assistant messages, include thinking block if present
            const content = [];
            if (msg.thinking) {
              const thinkingBlock = { type: 'thinking', thinking: msg.thinking };
              if (msg.signature) {
                thinkingBlock.signature = msg.signature;
              }
              content.push(thinkingBlock);
            }
            content.push({ type: 'text', text: msg.content[0].text });
            return { role: 'assistant', content };
          }
        });

        // Start streaming
        this.state.isStreaming = true;
        this.state.currentThinking = '';
        this.state.currentResponse = '';
        this.state.currentSignature = '';
        this.state.currentBlockType = null;
        this.updateSendButton(true);

        // Create streaming message container
        this.createStreamingMessage();

        try {
          await this.streamResponse(apiMessages);
        } catch (error) {
          this.handleError(error);
        } finally {
          this.state.isStreaming = false;
          this.updateSendButton(false);
        }
      },

      createStreamingMessage() {
        const messagesContainer = document.getElementById('messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message assistant streaming';
        messageDiv.id = 'streaming-message';
        messageDiv.innerHTML = `
          <div class="message-header">
            <span class="message-role">Assistant</span>
          </div>
          <div class="message-content">
            <div id="streaming-thinking" style="display: none;"></div>
            <div id="streaming-response"></div>
            <div class="streaming-indicator">
              <div class="dot"></div>
              <div class="dot"></div>
              <div class="dot"></div>
            </div>
          </div>
        `;
        messagesContainer.appendChild(messageDiv);
        this.scrollToBottom();
      },

      async streamResponse(messages) {
        this.state.abortController = new AbortController();

        const response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'x-api-key': CONFIG.ANTHROPIC_API_KEY,
            'anthropic-version': '2023-06-01',
            'content-type': 'application/json',
            'anthropic-dangerous-direct-browser-access': 'true'
          },
          body: JSON.stringify({
            model: CONFIG.MODEL || 'claude-haiku-4-5-20251001',
            max_tokens: CONFIG.MAX_TOKENS || 4096,
            stream: true,
            system: SYSTEM_PROMPT,
            thinking: {
              type: 'enabled',
              budget_tokens: CONFIG.THINKING_BUDGET || 1024
            },
            messages: messages
          }),
          signal: this.state.abortController.signal
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error?.message || 'API request failed');
        }

        const reader = response.body
          .pipeThrough(new TextDecoderStream())
          .getReader();

        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += value;
          const lines = buffer.split('\n');
          buffer = lines.pop();

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = line.slice(6).trim();
              if (data === '[DONE]') continue;

              try {
                const event = JSON.parse(data);
                this.handleStreamEvent(event);
              } catch (e) {
                console.error('Parse error:', e, data);
              }
            }
          }
        }

        this.finalizeStreamingMessage();
      },

      handleStreamEvent(event) {
        switch (event.type) {
          case 'content_block_start':
            this.state.currentBlockType = event.content_block?.type;
            if (event.content_block?.type === 'thinking') {
              document.getElementById('streaming-thinking').style.display = 'block';
            }
            break;

          case 'content_block_delta':
            if (event.delta?.type === 'thinking_delta') {
              this.state.currentThinking += event.delta.thinking;
              this.updateStreamingThinking();
            } else if (event.delta?.type === 'text_delta') {
              this.state.currentResponse += event.delta.text;
              this.updateStreamingResponse();
            } else if (event.delta?.type === 'signature_delta') {
              this.state.currentSignature += event.delta.signature || '';
            }
            break;

          case 'content_block_stop':
            // If we just finished a thinking block, collapse it
            if (this.state.currentBlockType === 'thinking') {
              this.collapseStreamingThinking();
            }
            this.state.currentBlockType = null;
            break;

          case 'message_stop':
            // Message complete
            break;

          case 'error':
            throw new Error(event.error?.message || 'Stream error');
        }
      },

      updateStreamingThinking() {
        const thinkingDiv = document.getElementById('streaming-thinking');
        if (thinkingDiv && this.state.currentThinking) {
          const thinkingId = 'thinking-streaming';
          thinkingDiv.innerHTML = `
            <div class="thinking-block">
              <div class="thinking-header" onclick="ChatApp.toggleThinking('${thinkingId}')">
                <span>Extended Thinking</span>
                <span class="thinking-toggle" id="${thinkingId}-toggle">Hide</span>
              </div>
              <div class="thinking-content" id="${thinkingId}">
                ${this.escapeHtml(this.state.currentThinking)}
              </div>
            </div>
          `;
        }
      },

      collapseStreamingThinking() {
        const thinkingContent = document.getElementById('thinking-streaming');
        const thinkingToggle = document.getElementById('thinking-streaming-toggle');
        if (thinkingContent && thinkingToggle) {
          thinkingContent.classList.add('collapsed');
          thinkingToggle.textContent = 'Show';
        }
      },

      updateStreamingResponse() {
        const responseDiv = document.getElementById('streaming-response');
        if (responseDiv) {
          responseDiv.innerHTML = marked.parse(this.state.currentResponse);
          this.scrollToBottom();
        }
      },

      finalizeStreamingMessage() {
        const streamingMessage = document.getElementById('streaming-message');
        if (streamingMessage) {
          streamingMessage.remove();
        }

        // Add finalized message to state
        this.addMessage('assistant', this.state.currentResponse, this.state.currentThinking, this.state.currentSignature);

        // Reset streaming state
        this.state.currentThinking = '';
        this.state.currentResponse = '';
        this.state.currentSignature = '';
      },

      toggleThinking(id) {
        const content = document.getElementById(id);
        const toggle = document.getElementById(id + '-toggle');
        if (content && toggle) {
          content.classList.toggle('collapsed');
          toggle.textContent = content.classList.contains('collapsed') ? 'Show' : 'Hide';
        }
      },

      render() {
        const messagesContainer = document.getElementById('messages');
        const streamingMessage = document.getElementById('streaming-message');

        // Don't re-render if streaming
        if (streamingMessage) return;

        // Clear and rebuild (except streaming message)
        const messages = this.state.messages.map((msg, index) => {
          const thinking = msg.thinking || '';
          const thinkingId = `thinking-${index}`;

          if (msg.role === 'user') {
            return `
              <div class="message user">
                <div class="message-header">
                  <span class="message-role">You</span>
                </div>
                <div class="message-content">
                  ${this.escapeHtml(msg.content[0].text)}
                </div>
              </div>
            `;
          } else {
            return `
              <div class="message assistant">
                <div class="message-header">
                  <span class="message-role">Assistant</span>
                </div>
                <div class="message-content">
                  ${thinking ? `
                    <div class="thinking-block">
                      <div class="thinking-header" onclick="ChatApp.toggleThinking('${thinkingId}')">
                        <span>Extended Thinking</span>
                        <span class="thinking-toggle" id="${thinkingId}-toggle">Show</span>
                      </div>
                      <div class="thinking-content collapsed" id="${thinkingId}">
                        ${this.escapeHtml(thinking)}
                      </div>
                    </div>
                  ` : ''}
                  <div class="response-text">
                    ${marked.parse(msg.content[0].text)}
                  </div>
                </div>
              </div>
            `;
          }
        }).join('');

        messagesContainer.innerHTML = messages;
        this.scrollToBottom();
      },

      handleError(error) {
        console.error('Chat error:', error);

        const streamingMessage = document.getElementById('streaming-message');
        if (streamingMessage) {
          streamingMessage.remove();
        }

        // If this was the first message and it failed, revert to initial state
        if (this.state.messages.length === 1 && this.state.messages[0].role === 'user') {
          this.state.messages = []; // Clear the failed attempt
          this.renderInputArea(); // Show Compare button again
        }

        const messagesContainer = document.getElementById('messages');
        const errorDiv = document.createElement('div');
        errorDiv.className = 'message assistant';
        errorDiv.innerHTML = `
          <div class="message-header">
            <span class="message-role">Error</span>
          </div>
          <div class="message-content">
            <div class="error-message">
              <strong>Error:</strong> ${this.escapeHtml(error.message)}
              ${this.state.messages.length === 0 ? '<br><small>Try clicking "Compare Documents" again.</small>' : ''}
            </div>
          </div>
        `;
        messagesContainer.appendChild(errorDiv);
        this.scrollToBottom();
      },

      updateSendButton(disabled) {
        const button = document.getElementById('send-button');
        button.disabled = disabled;
        button.textContent = disabled ? 'Sending...' : 'Send';
      },

      scrollToBottom() {
        const container = document.getElementById('messages');
        container.scrollTop = container.scrollHeight;
      },

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      },

      // File Upload Functions
      initFileUpload() {
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');

        // Click to browse
        dropZone.addEventListener('click', () => {
          fileInput.click();
        });

        // File selection
        fileInput.addEventListener('change', (e) => {
          this.handleFileSelect(e.target.files);
          fileInput.value = ''; // Reset input
        });

        // Drag and drop
        dropZone.addEventListener('dragover', (e) => this.handleDragOver(e));
        dropZone.addEventListener('dragleave', (e) => this.handleDragLeave(e));
        dropZone.addEventListener('drop', (e) => this.handleDrop(e));
      },

      toggleFilesPanel() {
        this.state.filesPanelExpanded = !this.state.filesPanelExpanded;
        const content = document.getElementById('files-content');
        const toggle = document.getElementById('files-toggle');

        if (this.state.filesPanelExpanded) {
          content.classList.remove('collapsed');
          toggle.classList.remove('collapsed');
          toggle.textContent = '‚ñº';
        } else {
          content.classList.add('collapsed');
          toggle.classList.add('collapsed');
          toggle.textContent = '‚ñ∂';
        }
      },

      handleFileSelect(files) {
        if (files.length === 0) return;

        Array.from(files).forEach(file => {
          this.uploadFile(file);
        });
      },

      handleDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        const dropZone = document.getElementById('drop-zone');
        dropZone.classList.add('dragging');
      },

      handleDragLeave(e) {
        e.preventDefault();
        e.stopPropagation();
        const dropZone = document.getElementById('drop-zone');
        if (e.target === dropZone) {
          dropZone.classList.remove('dragging');
        }
      },

      handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        const dropZone = document.getElementById('drop-zone');
        dropZone.classList.remove('dragging');

        const files = e.dataTransfer.files;
        this.handleFileSelect(files);
      },

      async uploadFile(file) {
        // Validate file size (32 MB limit for API requests)
        const maxSize = 32 * 1024 * 1024; // 32 MB in bytes
        if (file.size > maxSize) {
          alert(`File "${file.name}" is too large. Maximum size is 32 MB per file for direct upload.`);
          return;
        }

        // Create temporary file card
        const tempId = 'file-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        const fileObj = {
          id: tempId,
          filename: file.name,
          size: file.size,
          mimeType: file.type || 'application/pdf',
          status: 'uploading',
          uploadedAt: new Date().toISOString(),
          base64Data: null
        };

        this.state.uploadedFiles.push(fileObj);
        this.renderFilesList();
        this.updateFilesCount();

        try {
          // Read file as base64
          const base64Data = await this.readFileAsBase64(file);

          // Update file object with base64 data
          const fileIndex = this.state.uploadedFiles.findIndex(f => f.id === tempId);
          if (fileIndex !== -1) {
            this.state.uploadedFiles[fileIndex].base64Data = base64Data;
            this.state.uploadedFiles[fileIndex].status = 'uploaded';
          }

          this.renderFilesList();
          this.renderInputArea(); // Update button state

        } catch (error) {
          console.error('Upload error:', error);

          // Mark file as error
          const fileIndex = this.state.uploadedFiles.findIndex(f => f.id === tempId);
          if (fileIndex !== -1) {
            this.state.uploadedFiles[fileIndex].status = 'error';
            this.state.uploadedFiles[fileIndex].error = error.message;
          }

          this.renderFilesList();
          this.renderInputArea(); // Update button state
          alert(`Failed to load "${file.name}": ${error.message}`);
        }
      },

      readFileAsBase64(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();

          reader.onload = () => {
            // Remove the data URL prefix (e.g., "data:application/pdf;base64,")
            const base64String = reader.result.split(',')[1];
            resolve(base64String);
          };

          reader.onerror = () => {
            reject(new Error('Failed to read file'));
          };

          reader.readAsDataURL(file);
        });
      },

      removeFile(fileId) {
        // Remove from state (base64 data is stored locally, no API cleanup needed)
        this.state.uploadedFiles = this.state.uploadedFiles.filter(f => f.id !== fileId);
        this.renderFilesList();
        this.updateFilesCount();
        this.renderInputArea(); // Update button state
      },

      renderFilesList() {
        const filesList = document.getElementById('files-list');

        if (this.state.uploadedFiles.length === 0) {
          filesList.innerHTML = '';
          return;
        }

        filesList.innerHTML = this.state.uploadedFiles.map(file => {
          const icon = this.getFileIcon(file.mimeType);
          const statusClass = file.status;
          const statusText = file.status === 'uploading' ? 'Uploading...' :
                            file.status === 'uploaded' ? '‚úì Uploaded' :
                            '‚úó Error';

          return `
            <div class="file-card ${statusClass}">
              <div class="file-icon">${icon}</div>
              <div class="file-info">
                <div class="file-name">${this.escapeHtml(file.filename)}</div>
                <div class="file-meta">
                  <span class="file-size">${this.formatFileSize(file.size)}</span>
                  <span class="file-status ${statusClass}">${statusText}</span>
                </div>
              </div>
              <button class="file-remove" onclick="ChatApp.removeFile('${file.id}')" title="Remove file">
                √ó
              </button>
            </div>
          `;
        }).join('');
      },

      updateFilesCount() {
        const count = this.state.uploadedFiles.length;
        const filesCount = document.getElementById('files-count');
        filesCount.textContent = `(${count} ${count === 1 ? 'file' : 'files'})`;
      },

      formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return Math.round(bytes / Math.pow(k, i) * 10) / 10 + ' ' + sizes[i];
      },

      getFileIcon(mimeType) {
        if (!mimeType) return 'üìÑ';

        if (mimeType.includes('pdf')) return 'üìï';
        if (mimeType.includes('image')) return 'üñºÔ∏è';
        if (mimeType.includes('word') || mimeType.includes('document')) return 'üìò';
        if (mimeType.includes('spreadsheet') || mimeType.includes('excel') || mimeType.includes('csv')) return 'üìä';
        if (mimeType.includes('text')) return 'üìù';

        return 'üìÑ';
      }
    };

    // Check if config is loaded
    if (typeof CONFIG === 'undefined' || !CONFIG.ANTHROPIC_API_KEY) {
      document.body.innerHTML = `
        <div style="padding: 40px; text-align: center;">
          <h2 style="color: var(--error);">Configuration Error</h2>
          <p>Please create a <code>config.js</code> file with your Anthropic API key.</p>
          <p>See <code>config.example.js</code> for template.</p>
        </div>
      `;
    } else {
      // Initialize app
      ChatApp.init();
    }
  </script>
</body>
</html>
